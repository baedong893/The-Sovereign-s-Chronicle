<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Sovereign's Chronicle(ë°ëª¨3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Orbitron:wght@400;700&family=Source+Code+Pro:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #111827; /* Dark blue-gray */
            color: #e0e0e0;
        }
        .font-orbitron {
            font-family: 'Orbitron', sans-serif;
        }
        .font-mono {
            font-family: 'Source Code Pro', monospace;
        }
        #container {
            max-width: 900px;
            margin: auto;
            background-color: #1f2937; /* Tailwind gray-800 */
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            border-color: #374151; /* Tailwind gray-700 */
        }
        .choice-button {
            transition: all 0.2s ease-in-out;
            border-width: 1px;
            border-color: #4b5563; /* gray-600 */
            background-color: #374151; /* gray-700 */
        }
        .choice-button:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(251, 191, 36, 0.2); /* Yellow glow */
            background-color: #4b5563; /* gray-600 */
            border-color: #fbbf24; /* amber-300 */
        }
        .choice-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .header-button {
            transition: all 0.2s ease-in-out;
        }
        .header-button:hover {
            background-color: #f3b418;
            color: #1a1a1a;
        }
        .ui-panel-item {
            border-left: 3px solid #f3b418; /* Changed to theme yellow */
        }
        .narrative-quote {
            border-left: 4px solid #a3a3a3;
            background-color: rgba(0,0,0,0.1);
        }
        .combat-log {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .animate-fadeIn {
            animation: fadeIn 0.8s ease-in-out;
        }
        /* Scrollbar styles */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2a2a2a;
        }
        ::-webkit-scrollbar-thumb {
            background: #555;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #777;
        }
        /* Gemini Loading & Modal Overlay */
        .overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            z-index: 9999;
            display: flex;
            
            color: white;
            flex-direction: column;
            gap: 1rem;
            font-size: 1.2rem;
        }
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #f3b418;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .modal-content {
            background-color: #2a2a2a;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            width: 90%;
            max-width: 500px;
        }
        .modal-input {
            width: 100%;
            padding: 0.75rem;
            border-radius: 4px;
            background-color: #1a1a1a;
            border: 1px solid #555;
            color: #e0e0e0;
        }
        .speaker-button {
            cursor: pointer;
            transition: color 0.2s;
            display: inline-block;
            vertical-align: middle;
            margin-left: 8px;
        }
        .speaker-button:hover {
            color: #f3b418;
        }
        #advisor-modal-content {
            background-color: #2a2a2a;
            border: 2px solid #555;
            box-shadow: 0 0 15px rgba(0,0,0,0.7);
            color: #e0e0e0;
            width: 95%;
            max-width: 800px;
        }
        .advisor-portrait-cell {
            border: 2px solid #444;
            background-color: rgba(0,0,0,0.2);
            padding: 4px;
        }
        .advisor-portrait {
            height: 128px;
            width: 128px;
            cursor: pointer;
            border: 4px solid transparent;
            transition: border-color 0.2s;
        }
        .advisor-portrait.selected {
            border-color: #f3b418;
        }
        .dialogue-entry {
            margin-bottom: 8px;
        }
        .ui-tooltip {
            position: relative;
            cursor: help;
        }
        .ui-tooltip .tooltip-text {
            visibility: hidden;
            width: 250px;
            background-color: #1a1a1a;
            color: #fff;
            text-align: left;
            border-radius: 6px;
            padding: 10px;
            position: fixed; /* Changed from absolute to fixed */
            z-index: 10000; /* Increased z-index for safety */
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid #555;
            font-size: 0.9rem;
            line-height: 1.5;
            /* Removed positioning properties like bottom, left, margin-left */
        }
        /* Toggle Switch CSS */
        .toggle-switch:checked ~ .dot {
            transform: translateX(100%);
            background-color: #f3b418;
        }
        .toggle-switch:checked ~ .block {
            background-color: #374151;
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }
        .collapsible-header .arrow {
            transition: transform 0.3s;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="gemini-loading-overlay" class="overlay hidden justify-center items-center">
        <div class="spinner"></div>
        <p>âœ¨ Geminiê°€ ìƒˆë¡œìš´ ì—­ì‚¬ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘...</p>
    </div>

    <!-- Modals -->
    <div id="api-settings-modal" class="overlay hidden justify-center items-center">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4 text-yellow-300">ì„¤ì •</h3>
            
            <div class="bg-gray-800 p-3 rounded-md mb-4">
                <label for="modal-api-key-input" class="block mb-2 text-sm font-medium text-gray-300">Gemini API í‚¤ (ì„ íƒ ì‚¬í•­)</label>
                <input type="password" id="modal-api-key-input" placeholder="ì—¬ê¸°ì— API í‚¤ë¥¼ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”" class="modal-input">
                <p class="text-xs text-gray-400 mt-2">
                    API í‚¤ëŠ” <a href="https://aistudio.google.com/api-keys" target="_blank" class="text-blue-400 hover:underline">Google AI Studio</a>ì—ì„œ ë°œê¸‰ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
                </p>
            </div>
    
            <div class="bg-gray-800 p-3 rounded-md mb-4">
                <label class="flex items-center cursor-pointer">
                    <div class="relative">
                        <input type="checkbox" id="image-api-toggle" class="sr-only toggle-switch">
                        <div class="block bg-gray-600 w-14 h-8 rounded-full"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition"></div>
                    </div>
                    <div class="ml-3 text-gray-300 font-medium">
                        API í‚¤ë¡œ ì´ë¯¸ì§€ ìƒì„± ì‚¬ìš©
                    </div>
                </label>
                <p class="mt-2 text-xs text-gray-400">
                    API í‚¤ì— ì´ë¯¸ì§€ ìƒì„± ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì–´ ìˆì§€ ì•Šìœ¼ë©´ ì‘ë™í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ì´ ì˜µì…˜ì„ ì¼œë©´ ì…ë ¥í•œ API í‚¤ë¡œ ì´ë¯¸ì§€ë¥¼ ìƒì„±í•˜ë©°, ë„ë©´ API í‚¤ëŠ” ëŒ€í™” ê¸°ëŠ¥ì—ë§Œ ì‚¬ìš©ë©ë‹ˆë‹¤.
                </p>
            </div>

            <div class="bg-gray-800 p-3 rounded-md mb-6">
                <label class="flex items-center cursor-pointer">
                    <div class="relative">
                        <input type="checkbox" id="fatigue-system-toggle" class="sr-only toggle-switch">
                        <div class="block bg-gray-600 w-14 h-8 rounded-full"></div>
                        <div class="dot absolute left-1 top-1 bg-white w-6 h-6 rounded-full transition"></div>
                    </div>
                    <div class="ml-3 text-gray-300 font-medium">
                        í”¼ë¡œë„ ë° ê·¼ë¬´ ì‹œê°„ ì‹œìŠ¤í…œ í™œì„±í™”
                    </div>
                </label>
                <p class="mt-2 text-xs text-gray-400">
                    ì§€ë„ìì˜ ê±´ê°• ìƒíƒœì™€ ì‹œê°„ ì œì•½ì„ ê²Œì„ì— ë„ì…í•˜ì—¬ í˜„ì‹¤ê°ì„ ë†’ì…ë‹ˆë‹¤.
                </p>
            </div>
            
            <div class="mt-6 flex justify-end gap-4">
                <button onclick="closeApiSettingsModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md">ì·¨ì†Œ</button>
                <button onclick="saveApiSettings()" class="px-4 py-2 bg-blue-700 hover:bg-blue-800 rounded-md font-bold">ì €ì¥</button>
            </div>
        </div>
    </div>
    
    <div id="era-choice-modal" class="overlay hidden justify-center items-center">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4 text-yellow-300">ì‹œëŒ€ ì„ íƒ</h3>
            <p class="text-gray-400 mb-4">ì‹œì‘í•˜ê³  ì‹¶ì€ ì‹œëŒ€, êµ­ê°€, ì‚¬ê±´ ë“±ì„ ììœ ë¡­ê²Œ ì…ë ¥í•˜ì„¸ìš”.</p>
            <textarea id="era-input" class="modal-input" rows="3" placeholder="ì˜ˆ: 1597ë…„ ëª…ëŸ‰í•´ì „, ì¡°ì„ "></textarea>
            <div class="mt-6 flex justify-end gap-4">
                <button onclick="hideEraModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md">ì·¨ì†Œ</button>
                <button onclick="generateCustomScenario()" class="px-4 py-2 bg-blue-700 hover:bg-blue-800 rounded-md font-bold">ìƒì„±</button>
            </div>
        </div>
    </div>
    <div id="image-modal" class="overlay hidden items-center justify-center p-4" style="background-color: rgba(0, 0, 0, 0.85);">
        <button onclick="closeImageModal()" class="absolute top-4 right-6 text-white text-5xl font-bold hover:text-gray-300 transition">&times;</button>
        <img id="modal-image" src="" alt="Enlarged event image" class="max-w-full max-h-full object-contain rounded-md shadow-lg">
    </div>
    
    <div id="report-modal" class="overlay hidden justify-center items-center">
        <div class="modal-content">
            <h3 id="report-title" class="text-xl font-bold mb-4 text-yellow-300">íŠ¹ë³„ ë³´ê³ </h3>
            <div id="report-content" class="text-gray-300 mb-6 max-h-96 overflow-y-auto"></div>
            <div class="mt-6 flex justify-end gap-4">
                <button onclick="closeReportModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md text-white">ë‹«ê¸°</button>
            </div>
        </div>
    </div>

    <div id="advisor-selector-modal" class="overlay hidden justify-center items-center">
        <div id="advisor-modal-content" class="modal-content p-4">
            <h2 id="advisor-council-title" class="text-2xl font-bold text-center text-yellow-300 mb-4 font-mono tracking-wider">HIGH COUNCIL</h2>
            <div id="advisor-portraits-container" class="grid grid-cols-5 gap-2 mb-4 p-2 rounded">
                <!-- Advisor portraits and roles will be generated here -->
            </div>
            <p class="text-center text-sm text-gray-400 mb-4">í† ë¡ ì— ì°¸ì—¬ì‹œí‚¬ ì¡°ì–¸ìë¥¼ ì„ íƒí•˜ì‹­ì‹œì˜¤.</p>
            <div class="mt-6 flex justify-end gap-4">
                <button onclick="closeAdvisorSelector()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md text-white">ì·¨ì†Œ</button>
                <button onclick="startAdvisorDiscussion()" class="px-6 py-2 bg-blue-700 hover:bg-blue-800 text-white border-2 border-blue-500 rounded-md font-bold">ì˜ê²¬ ì¢…í•©</button>
            </div>
        </div>
    </div>
    
    <div id="intelligence-modal" class="overlay hidden justify-center items-center">
        <div class="modal-content w-full max-w-2xl">
             <h3 class="text-xl font-bold mb-4 text-yellow-300">ì²©ë³´ ë³¸ë¶€</h3>
             <div id="intelligence-actions-list" class="space-y-3 max-h-80 overflow-y-auto">
                 <!-- Intelligence actions will be rendered here -->
             </div>
             <div class="mt-6 flex justify-end gap-4">
                 <button onclick="closeIntelligenceModal()" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md">ë‹«ê¸°</button>
             </div>
        </div>
    </div>

    <div id="input-modal" class="overlay hidden justify-center items-center">
        <div class="modal-content">
            <h3 id="input-modal-title" class="text-xl font-bold mb-4 text-yellow-300"></h3>
            <p id="input-modal-prompt" class="text-gray-400 mb-4"></p>
            <textarea id="input-modal-textarea" class="modal-input" rows="2"></textarea>
            <div class="mt-6 flex justify-end gap-4">
                <button id="input-modal-cancel" class="px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md">ì·¨ì†Œ</button>
                <button id="input-modal-submit" class="px-4 py-2 bg-blue-700 hover:bg-blue-800 rounded-md font-bold">í™•ì¸</button>
            </div>
        </div>
    </div>

     <div id="action-confirm-modal" class="overlay hidden justify-center items-center">
        <div class="modal-content">
            <h3 class="text-xl font-bold mb-4 text-yellow-300">ë¹„ê·¼ë¬´ ì‹œê°„ì…ë‹ˆë‹¤</h3>
            <p class="text-gray-400 mb-6">í˜„ì¬ëŠ” ì—…ë¬´ ì‹œê°„ì´ ì•„ë‹™ë‹ˆë‹¤. ì–´ë–»ê²Œ í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
            <div class="space-y-3">
                 <button id="action-confirm-emergency" class="w-full px-4 py-3 bg-red-800 hover:bg-red-700 rounded-md font-bold">ë¹„ìƒ ê·¼ë¬´ ì„ í¬ (í”¼ë¡œë„ ê¸‰ì¦)</button>
                 <button id="action-confirm-rest" class="w-full px-4 py-3 bg-blue-700 hover:bg-blue-600 rounded-md font-bold">ë‹¤ìŒ ë‚  ì•„ì¹¨ê¹Œì§€ íœ´ì‹</button>
                 <button id="action-confirm-cancel" class="w-full px-4 py-2 bg-gray-600 hover:bg-gray-700 rounded-md mt-4">ì·¨ì†Œ</button>
            </div>
        </div>
    </div>


    <div id="container" class="rounded-lg overflow-hidden border">
        <header class="bg-gray-900 p-4 border-b border-gray-700 flex justify-between items-center gap-4">
            <div class="flex items-center">
                <button onclick="openApiSettingsModal()" class="header-button p-2 rounded-md" title="API ì„¤ì •">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="-1 -1 26 26" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </button>
            </div>
            <h1 class="text-xl md:text-2xl font-orbitron text-center text-yellow-300 tracking-wider flex-grow">The Sovereign's Chronicle(ë°ëª¨3)</h1>
            <div id="pre-game-header-buttons" class="flex gap-2">
                <button onclick="generateRandomScenario()" class="header-button text-sm px-3 py-1 border border-yellow-400 text-yellow-400 rounded-md">ëœë¤ ì‹œëŒ€</button>
                <button onclick="showEraModal()" class="header-button text-sm px-3 py-1 border border-yellow-400 text-yellow-400 rounded-md">ì‹œëŒ€ ì„ íƒ</button>
            </div>
            <div id="in-game-header-buttons" class="hidden flex gap-2">
                <button onclick="openIntelligenceModal()" class="header-button text-sm px-3 py-1 border border-yellow-400 text-yellow-400 rounded-md" title="ì²©ë³´ ë³¸ë¶€ ì—´ê¸°">ğŸ” ì²©ë³´</button>
                <button onclick="openAdvisorSelector()" class="header-button text-sm px-3 py-1 border border-yellow-400 text-yellow-400 rounded-md" title="ìë¬¸íšŒ ì†Œì§‘">âœ¨ ìë¬¸íšŒ</button>
            </div>
        </header>

        <main id="game-window" class="p-4 md:p-6 min-h-screen">
            <!-- Start Screen -->
            <div id="start-screen">
                <div id="briefing-paper" class="text-gray-800 p-6 md:p-8 rounded-md shadow-lg max-w-3xl mx-auto" style="background-color: #F5EEDC; background-image: url('https://www.toptal.com/designers/subtlepatterns/patterns/crumply.png');">
                    <div id="briefing-header">
                        <div class="border-b-2 border-gray-400 pb-2 mb-4">
                            <h2 id="briefing-title" class="text-xl font-bold text-center text-gray-800 font-mono">SOVEREIGN'S CHRONICLE</h2>
                            <p id="briefing-subtitle" class="text-sm text-center text-gray-600 font-mono">A DYNAMIC HISTORY SIMULATOR</p>
                        </div>
                    </div>
                    <div id="briefing-content" class="space-y-4 text-lg">
                        <div id="briefing-metadata">
                            <!-- This will be populated by JS -->
                        </div>
                        <hr id="briefing-hr" class="my-4 border-gray-300 hidden">
                        <p id="briefing-body" class="text-center italic text-gray-600 py-8">
                            ìƒë‹¨ì˜ [ëœë¤ ì‹œëŒ€] ë˜ëŠ” [ì‹œëŒ€ ì„ íƒ] ë²„íŠ¼ì„ ëˆŒëŸ¬ ë‹¹ì‹ ì˜ ì—°ëŒ€ê¸°ë¥¼ ì‹œì‘í•˜ì‹­ì‹œì˜¤.
                        </p>
                    </div>
                    <div id="briefing-footer" class="mt-8 pt-4 border-t-2 border-gray-400 text-center">
                        <button id="start-button" onclick="startGame(this.dataset.scenarioId)" disabled class="w-full md:w-auto px-8 py-3 bg-blue-800 text-white font-bold text-xl rounded-md choice-button border-transparent tracking-wider opacity-50 cursor-not-allowed">
                            [ ì—°ëŒ€ê¸° ì‹œì‘ ]
                        </button>
                    </div>
                </div>
            </div>

            <!-- Game Content (hidden by default) -->
            <div id="game-content" class="hidden">
                <div id="event-image-container" class="relative mb-4 rounded-lg overflow-hidden h-64 bg-gray-900 flex items-center justify-center">
                    <!-- Image or loading indicator will go here -->
                </div>
                <div id="narrative-output" class="mb-6 space-y-4 text-lg leading-relaxed"></div>
                
                <div id="ui-panel-container" class="my-6">
                    <!-- UI Panel will be rendered here by JS -->
                </div>

                <div id="time-panel-container" class="my-6"></div>

                <div id="research-panel-container" class="my-6"></div>
                
                <div id="national-spirits-container" class="my-6">
                            <!-- National Spirits will be rendered here -->
                </div>

                <div id="internal-factions-container" class="my-6">
                            <!-- Internal Factions will be rendered here -->
                </div>

                <div id="factions-container" class="my-6">
                            <!-- Factions will be rendered here -->
                </div>
                
                <div id="leader-traits-container" class="my-6">
                            <!-- Leader Traits will be rendered here -->
                </div>

                <div id="advisor-discussion-container" class="hidden my-6">
                    <h3 class="font-bold text-lg mb-2 text-yellow-400 border-b-2 border-gray-600 pb-2">ìë¬¸íšŒ í† ë¡ </h3>
                    <div id="advisor-discussion-log" class="mt-4 space-y-2 text-sm bg-gray-900 p-4 rounded-md  max-h-48 overflow-y-auto">
                        <!-- Discussion log will be rendered here -->
                    </div>
                     <div class="mt-4 flex gap-2">
                         <textarea id="advisor-input" class="modal-input flex-grow" rows="1" placeholder="ììœ ë¡­ê²Œ ì§ˆë¬¸í•˜ì—¬ íšŒì˜ë¥¼ ì´ì–´ê°€ì„¸ìš”..."></textarea>
                         <button onclick="continueMainScreenDiscussion()" class="px-4 py-2 bg-green-700 hover:bg-green-800 rounded-md font-bold text-white">ì „ì†¡</button>
                     </div>
                </div>

                <div id="choices-container" class="mt-8 border-t-2 border-gray-600 pt-6">
                    <h3 id="choices-prompt" class="font-bold text-lg mb-4 text-yellow-400"></h3>
                    <div id="choices-list" class="space-y-3">
                        <!-- Choices will be rendered here by JS -->
                    </div>
                    <div id="custom-action-container" class="mt-6 pt-4 border-t border-dashed border-gray-500">
                        <h4 class="text-md font-bold text-gray-400 mb-2">í˜¹ì€, ì§ì ‘ í–‰ë™ì„ ì§€ì‹œí•˜ì‹­ì‹œì˜¤:</h4>
                        <div class="flex gap-2">
                            <textarea id="custom-action-input" class="modal-input flex-grow" rows="2" placeholder="ì˜ˆ: 'ì¥êµ°ì„ ì¦‰ì‹œ ì†Œí™˜í•˜ì—¬ êµ°ì‚¬ íšŒì˜ë¥¼ ì—´ì–´ë¼.' ë˜ëŠ” 'êµ­ê³ ë¥¼ í™•ì¸í•˜ê³  ì˜ˆì‚°ì„ ì¬ë¶„ë°°í•˜ë¼.'"></textarea>
                            <button onclick="handleCustomAction()" class="px-6 py-2 bg-yellow-600 hover:bg-yellow-700 rounded-md font-bold text-black" title="AIì—ê²Œ ììœ ë¡œìš´ ëª…ë ¹ì„ ë‚´ë¦½ë‹ˆë‹¤.">ì§€ì‹œ</button>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>
    
    <audio id="tts-audio-player" class="hidden"></audio>

<script>
// --- GLOBAL API KEY & SETTINGS ---
let userApiKey = "";
let useCustomImageApi = false;
let useFatigueSystem = false;

// --- GAME DATA & CONFIG ---
const TECH_LEVEL_NAMES = [
    "ì„ ì‚¬ ì‹œëŒ€",     // Level 0
    "ê¸°ì´ˆê³¼í•™ ìˆ˜ì¤€", // Level 1
    "ì‘ìš©ê³¼í•™ íƒœë™", // Level 2
    "ì²´ê³„ì  ì—°êµ¬",   // Level 3
    "ê¸°ìˆ ì  í˜ì‹ ",   // Level 4
    "ê³¼í•™ì˜ ì„ êµ¬ì", // Level 5
    "ì›ìë ¥ ì‹œëŒ€",   // Level 6
    "ë””ì§€í„¸ ì‹œëŒ€",   // Level 7
    "ì •ë³´í™” ì‹œëŒ€",   // Level 8
    "ìš°ì£¼ ê°œì²™ ì‹œëŒ€", // Level 9
    "ì´ˆê¸°ìˆ  ì‹œëŒ€"   // Level 10
];

const STAT_TRANSLATIONS = {
    stability: 'êµ­ê°€ ì•ˆì •ë„',
    approval: 'ì§€ì§€ë„',
    politicalPower: 'ê¶Œë ¥',
    treasury: 'êµ­ê³ ',
    manpower: 'ê°€ìš© ì¸ë ¥',
    resources: 'êµ­ê°€ ìì›',
    techLevel: 'ê¸°ìˆ  ìˆ˜ì¤€',
    powerInfluence: 'ê¶Œë ¥ ì˜í–¥ë ¥',
    stability_bonus: 'êµ­ê°€ ì•ˆì •ë„',
    approval_bonus: 'ì§€ì§€ë„',
    politicalPower_bonus: 'ê¶Œë ¥',
    local_autonomy: 'ì§€ë°© ìì¹˜ë„',
    stability_loss_threshold: 'ì•ˆì •ë„ í•˜ë½ ì„ê³„ì¹˜',
    long_term_project_success_rate: 'ì¥ê¸° í”„ë¡œì íŠ¸ ì„±ê³µë¥ ',
    treasury_consumption_modifier: 'êµ­ê³  ì†Œëª¨ìœ¨',
    advisor_satisfaction: 'ìë¬¸íšŒ ë§Œì¡±ë„'
};


const HISTORICAL_KEYWORDS = {
    'default': {
        positive: 'historical painting, detailed, cinematic lighting',
        negative: 'text, watermark, signature, modern clothing'
    },
    'ì¡°ì„ ': {
        positive: 'Joseon dynasty, hanbok, traditional Korean architecture, palace, gwana, gat',
        negative: 'text, watermark, signature, modern clothing, samurai, ninja'
    },
    'ë¡œë§ˆ': {
        positive: 'Roman empire, toga, senate, legionary armor, laurels, marble architecture',
        negative: 'text, watermark, signature, modern clothing, knights'
    }
};

// --- UTILITY FUNCTIONS ---

function updateFatigue(hoursPassed, isResting = false, isEmergency = false) {
    if (!useFatigueSystem) return;
    let fatigue = game.state.playerNation.fatigue;
    if (isResting) {
        fatigue -= hoursPassed * 4; // Recover 4 fatigue per hour of rest
    } else {
        let rate = 1; // 1 fatigue per hour
        if (isEmergency) { rate = 3; }
        const now = new Date(game.state.world.date);
        const currentHour = now.getHours();
        if (currentHour < 7 || currentHour > 22) { rate *= 2; } // Double fatigue gain during deep night
        fatigue += hoursPassed * rate;
    }
    game.state.playerNation.fatigue = Math.max(0, Math.min(100, fatigue));
}

function advanceTimeAndAnimate(duration, onComplete) {
    if (!game.state || !game.state.world) {
        if(onComplete) onComplete();
        return;
    }

    const startDate = new Date(game.state.world.date);
    let endDate = new Date(startDate);

    endDate.setDate(endDate.getDate() + (duration.days || 0));
    endDate.setHours(endDate.getHours() + (duration.hours || 0));
    endDate.setMinutes(endDate.getMinutes() + (duration.minutes || 0));
    endDate.setSeconds(endDate.getSeconds() + (duration.seconds || 0));
    
    const dateEl = document.getElementById('time-panel-date');
    const timeEl = document.getElementById('time-panel-time');

    if (!dateEl || !timeEl) {
        game.state.world.date = endDate.toISOString();
        if (useFatigueSystem) {
             const hoursPassed = (endDate - startDate) / (1000 * 60 * 60);
             updateFatigue(hoursPassed, duration.isResting, game.state.world.isEmergency);
        }
        if (onComplete) onComplete();
        return;
    }
    
    const originalState = JSON.parse(JSON.stringify(game.state));
    const totalSecondsToAdd = (endDate - startDate) / 1000;
    const totalHoursToAdd = totalSecondsToAdd / 3600;
    const totalDaysToAdd = totalHoursToAdd / 24;
    const income = game.state.playerNation.income || { treasury: 10, manpower: 5, resources: 1 };

    const totalChanges = {
        treasury: (income.treasury || 0) * totalDaysToAdd,
        manpower: (income.manpower || 0) * totalDaysToAdd,
        resources: (income.resources || 0) * totalDaysToAdd,
        factions: {},
        internalFactions: {}
    };
    
    game.state.factions.forEach(f => {
        totalChanges.factions[f.id] = (Math.random() - 0.5) * totalDaysToAdd * 0.5; // Small random drift
    });
    game.state.internalFactions.forEach(f => {
        totalChanges.internalFactions[f.id] = (Math.random() - 0.5) * totalDaysToAdd * 0.5; // Small random drift
    });

    let currentAnimDate = new Date(startDate);
    const totalDurationMs = 1500;
    const intervalTime = 50;
    const totalSteps = totalDurationMs / intervalTime;

    let step = 0;
    const timer = setInterval(() => {
        step++;
        const proportion = step / totalSteps;

        if (step >= totalSteps) {
            clearInterval(timer);
            game.state = originalState;
            game.state.world.date = endDate.toISOString();
             if (useFatigueSystem) {
                const hoursPassed = (endDate - startDate) / (1000 * 60 * 60);
                updateFatigue(hoursPassed, duration.isResting, game.state.world.isEmergency);
            }
            game.state.playerNation.treasury += totalChanges.treasury;
            game.state.playerNation.manpower += totalChanges.manpower;
            game.state.playerNation.resources += totalChanges.resources;
            game.state.factions.forEach(f => f.relationship = Math.max(-100, Math.min(100, f.relationship + (totalChanges.factions[f.id] || 0))));
            game.state.internalFactions.forEach(f => f.loyalty = Math.max(0, Math.min(100, f.loyalty + (totalChanges.internalFactions[f.id] || 0))));

            // Final research update
            if (game.state.research && game.state.research.currentProject) {
                const hoursPassed = (endDate - startDate) / (1000 * 60 * 60);
                game.state.research.timeElapsed += hoursPassed;
                let progress = (game.state.research.timeElapsed / game.state.research.currentProject.totalTime) * 100;
                game.state.research.progress = Math.min(progress, 100);

                if (game.state.research.progress >= 100) {
                    const completedProject = game.state.research.currentProject;
                    openReportModal("ì—°êµ¬ ì™„ë£Œ", `[${completedProject.name}] ì—°êµ¬ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!`);
                    
                    if (completedProject.effects) {
                        game.applyEffects(completedProject.effects); 
                    }
                    
                    game.state.research.currentProject = null;
                    game.state.research.progress = 0;
                    game.state.research.timeElapsed = 0;
                }
            }

            game.Renderer.renderUIPanel();
            game.Renderer.renderCollapsiblePanels();
            if (onComplete) onComplete();
            return;
        }

        const newTimestamp = startDate.getTime() + (endDate.getTime() - startDate.getTime()) * proportion;
        currentAnimDate.setTime(newTimestamp);
        dateEl.textContent = formatHistoricalDate(currentAnimDate.toISOString());
        timeEl.textContent = currentAnimDate.toTimeString().split(' ')[0];

        // Update passive income
        game.state.playerNation.treasury = originalState.playerNation.treasury + totalChanges.treasury * proportion;
        game.state.playerNation.manpower = originalState.playerNation.manpower + totalChanges.manpower * proportion;
        game.state.playerNation.resources = originalState.playerNation.resources + totalChanges.resources * proportion;

        // Update research progress
        if (game.state.research && game.state.research.currentProject) {
            const hoursPassedThisProportion = totalHoursToAdd * proportion;
            game.state.research.timeElapsed = originalState.research.timeElapsed + hoursPassedThisProportion;
            let progress = (game.state.research.timeElapsed / game.state.research.currentProject.totalTime) * 100;
            game.state.research.progress = Math.min(progress, 100);
        }

        // Update faction drift
        game.state.factions.forEach((f, index) => {
            const finalValue = originalState.factions[index].relationship + (totalChanges.factions[f.id] || 0) * proportion;
            f.relationship = Math.max(-100, Math.min(100, finalValue));
        });
        game.state.internalFactions.forEach((f, index) => {
             const finalValue = originalState.internalFactions[index].loyalty + (totalChanges.internalFactions[f.id] || 0) * proportion;
            f.loyalty = Math.max(0, Math.min(100, finalValue));
        });
        
        game.Renderer.renderUIPanel();
        game.Renderer.renderCollapsiblePanels();
    }, intervalTime);
}

function estimateTimeForAction(text) {
    if (!text) return { hours: 1 };
    const lowerText = text.toLowerCase();
    
    if (lowerText.includes('ì „ìŸ') || lowerText.includes('ì›ì •') || lowerText.includes('ê±´ì„¤') || lowerText.includes('ì´ë™')) {
        return { hours: Math.floor(Math.random() * 4) + 2 };
    }
    if (lowerText.includes('íšŒì˜') || lowerText.includes('í† ë¡ ') || lowerText.includes('ë…¼ì˜') || lowerText.includes('ë§Œì°¬')) {
        return { hours: Math.floor(Math.random() * 2) + 1 };
    }
    if (lowerText.length > 50) {
        return { minutes: Math.floor(Math.random() * 45) + 15 };
    }
    return { minutes: Math.floor(Math.random() * 10) + 5 };
}


function formatHistoricalDate(dateString) {
    try {
        const d = new Date(dateString);
        let year = d.getUTCFullYear();
        const month = d.getUTCMonth() + 1;
        const day = d.getUTCDate();

        if (year < 0) {
            return `ê¸°ì›ì „ ${Math.abs(year)}ë…„ ${month}ì›” ${day}ì¼`;
        }
        return `${year}ë…„ ${month}ì›” ${day}ì¼`;
    } catch(e) {
        return "ë‚ ì§œ ì˜¤ë¥˜";
    }
}


function parseKoreanDateToISO(dateString) {
    if (!dateString || typeof dateString !== 'string') return new Date().toISOString();

    let year, month = 1, day = 1;
    const isBC = dateString.includes('ê¸°ì›ì „');
    const numbers = dateString.match(/\d+/g);

    if (!numbers || numbers.length === 0) return new Date().toISOString();

    year = parseInt(numbers[0], 10);
    if (isBC) {
        year = -year;
    }

    if (numbers.length > 1) month = parseInt(numbers[1], 10);
    if (numbers.length > 2) day = parseInt(numbers[2], 10);

    month = Math.max(1, Math.min(12, month));
    day = Math.max(1, Math.min(31, day));

    // Use UTC to avoid timezone issues
    const d = new Date(Date.UTC(year, month - 1, day, 9, 0, 0));
    return d.toISOString();
}


function base64ToArrayBuffer(base64) {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
}

function pcmToWav(pcmData, sampleRate) {
    const numChannels = 1; const bitsPerSample = 16;
    const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
    const blockAlign = numChannels * (bitsPerSample / 8);
    const dataSize = pcmData.length * (bitsPerSample / 8);
    const chunkSize = 36 + dataSize;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    view.setUint32(0, 0x52494646, false); // "RIFF"
    view.setUint32(4, chunkSize, true);
    view.setUint32(8, 0x57415645, false); // "WAVE"
    view.setUint32(12, 0x666d7420, false); // "fmt "
    view.setUint32(16, 16, true); // PCM format
    view.setUint16(20, 1, true); // Audio format 1
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitsPerSample, true);
    view.setUint32(36, 0x64617461, false); // "data"
    view.setUint32(40, dataSize, true);
    for (let i = 0; i < pcmData.length; i++) {
        view.setInt16(44 + i * 2, pcmData[i], true);
    }
    return new Blob([view], { type: 'audio/wav' });
}

function getCurrencySymbol(dateString, nationName = '') {
    const yearMatch = dateString.match(/^(-?\d+)/);
    if (!yearMatch) return 'ğŸ’°';
    const year = parseInt(yearMatch[1], 10);

    // 1. Nation-specific logic (prioritized)
    const lowerNationName = nationName.toLowerCase();
    if (lowerNationName.includes('ì¡°ì„ ') || lowerNationName.includes('korea') || lowerNationName.includes('ëŒ€í•œì œêµ­')) {
        if (year >= 1902) return 'â‚©';
        if (year >= 1400) return 'ëƒ¥';
        return 'æ–‡';
    }
    if (lowerNationName.includes('ë¡œë§ˆ') || lowerNationName.includes('rome')) {
        return 'D'; // Denarius
    }
    if (lowerNationName.includes('ì¼ë³¸') || lowerNationName.includes('japan')) {
        if (year >= 1871) return 'Â¥';
        return 'æ–‡'; // Mon
    }
    if (lowerNationName.includes('ì¤‘êµ­') || lowerNationName.includes('china')) {
        if (year >= 1948) return 'Â¥';
        if (year >= 1368) return 'ä¸¡'; // Tael
        return 'æ–‡'; // Wen
    }
    if (lowerNationName.includes('ì˜êµ­') || lowerNationName.includes('england') || lowerNationName.includes('britain')) {
        return 'Â£';
    }
    if (lowerNationName.includes('í”„ë‘ìŠ¤') || lowerNationName.includes('france')) {
        if (year >= 1795) return 'â‚£';
        return 'L'; // Livre
    }
    if (lowerNationName.includes('ë¯¸êµ­') || lowerNationName.includes('america')) {
        return '$';
    }
    if (lowerNationName.includes('ìŠ¤í˜ì¸') || lowerNationName.includes('spain')) {
         if (year >= 1869) return 'â‚§';
        return '$'; // Spanish Dollar (Peso) was the origin of the dollar sign
    }
    if (lowerNationName.includes('ë…ì¼') || lowerNationName.includes('germany')) {
        if (year >= 1924 && year <= 1948) return 'â„›â„³'; // Reichsmark
        if (year >= 1873) return 'â„³'; // Mark
        return 'Æ’'; // Gulden/Florin
    }
    if (lowerNationName.includes('ì´íƒˆë¦¬ì•„') || lowerNationName.includes('italy')) {
    if (year >= 1861) return 'â‚¤'; // Lira
    return 'S'; // Solidus or Florin
    }

    if (lowerNationName.includes('ëŸ¬ì‹œì•„') || lowerNationName.includes('russia')) {
    if (year >= 1998) return 'â‚½';
    return 'Ñ€ÑƒĞ±';
    }

    // 2. Generic era-based logic as fallback
    if (year < -500) return 'â‚¯'; // Drachma (Ancient Greece)
    if (year >= -500 && year < 1450) return 'S'; // Solidus (Byzantium/Rome)
    if (year >= 1450 && year < 1800) return '$'; // Spanish Dollar's influence
    if (year >= 1800 && year < 1945) return 'Â£'; // Pound Sterling's dominance
    if (year >= 1945) {
        if (year >= 1999) return 'â‚¬'; // Euro as a modern example
        return '$'; // US Dollar dominance
    }

    return 'ğŸ’°'; // Final fallback
}

function formatNumberWithKoreanUnits(num) {
    if (typeof num !== 'number') return num;
    const absNum = Math.abs(num);
    if (absNum < 1000000) { 
        return num.toLocaleString(undefined, { maximumFractionDigits: 0 });
    }
    const units = [
        { value: 1e12, name: 'ì¡°' },
        { value: 1e8, name: 'ì–µ' },
        { value: 1e6, name: 'ë°±ë§Œ' }
    ];
    for (const unit of units) {
        if (absNum >= unit.value) {
            const val = num / unit.value;
            const formattedVal = parseFloat(val.toFixed(2)).toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 2 });
            return `${formattedVal}${unit.name}`;
        }
    }
    return num.toLocaleString(undefined, { maximumFractionDigits: 0 });
}


// --- GEMINI API INTEGRATION ---
const GEMINI = {
    async callGeminiApi(systemPrompt, userPrompt, retries = 3, delay = 1000) {
        document.getElementById('gemini-loading-overlay').classList.remove('hidden');
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${userApiKey}`;
        const payload = {
            contents: [{ parts: [{ text: userPrompt }] }],
            systemInstruction: { parts: [{ text: systemPrompt }] },
        };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                if (response.status === 429 && retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return this.callGeminiApi(systemPrompt, userPrompt, retries - 1, delay * 2);
                }
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            const candidate = result.candidates?.[0];
            if (candidate && candidate.content?.parts?.[0]?.text) {
                return candidate.content.parts[0].text;
            } else {
                console.error("Invalid response structure from Gemini API:", result); return null;
            }
        } catch (error) {
            console.error("Gemini API call failed:", error); 
            showInfoModal("API í˜¸ì¶œ ì˜¤ë¥˜", `API í˜¸ì¶œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            return null;
        } finally {
            document.getElementById('gemini-loading-overlay').classList.add('hidden');
        }
    },

    async callTtsApi(text) {
        document.getElementById('gemini-loading-overlay').classList.remove('hidden');
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${userApiKey}`;
        const payload = {
            contents: [{ parts: [{ text: `Please read the following text in a clear, narrative tone for a historical game: ${text}` }] }],
            generationConfig: { responseModalities: ["AUDIO"], speechConfig: { voiceConfig: { prebuiltVoiceConfig: { voiceName: "Charon" } } } },
            model: "gemini-2.5-flash-preview-tts"
        };
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) { throw new Error(`TTS API error! status: ${response.status}`); }
            const result = await response.json();
            const part = result?.candidates?.[0]?.content?.parts?.[0];
            const audioData = part?.inlineData?.data;
            const mimeType = part?.inlineData?.mimeType;
            if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, sampleRate);
                return URL.createObjectURL(wavBlob);
            } else {
                console.error("Invalid TTS response structure:", result); return null;
            }
        } catch (error) {
            console.error("TTS API call failed:", error); 
            showInfoModal("ì˜¤ë””ì˜¤ ìƒì„± ì‹¤íŒ¨", `ì˜¤ë””ì˜¤ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ${error.message}`);
            return null;
        } finally {
            document.getElementById('gemini-loading-overlay').classList.add('hidden');
        }
    },

    async generateImage(prompt, retries = 3, delay = 1000) {
        let apiUrl, payload, apiKeyForImage;
        if (useCustomImageApi && userApiKey) {
            apiKeyForImage = userApiKey;
            apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/imagen-3.0-generate-002:predict?key=${apiKeyForImage}`;
            payload = {
                instances: [{ prompt: prompt }],
                parameters: { "sampleCount": 1 }
            };
        } else {
            apiKeyForImage = "";
            apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKeyForImage}`;
            payload = {
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: { responseModalities: ['IMAGE'] },
            };
        }
        try {
            const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            if (!response.ok) {
                if (response.status === 429 && retries > 0) {
                    await new Promise(res => setTimeout(res, delay));
                    return this.generateImage(prompt, retries - 1, delay * 2);
                }
                throw new Error(`Image generation HTTP error! status: ${response.status}`);
            }
            const result = await response.json();
            let base64Data;
            if (useCustomImageApi && userApiKey) {
                base64Data = result.predictions?.[0]?.bytesBase64Encoded;
            } else {
                base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
            }
            if (base64Data) {
                return `data:image/png;base64,${base64Data}`;
            } else {
                if (result.candidates?.[0]?.finishReason === "SAFETY") {
                    console.warn("Image generation blocked by safety filters.");
                    return null;
                }
                console.error("Invalid response structure from Image API:", result);
                return null;
            }
        } catch (error) {
            if (error.message && error.message.includes("429")) {
                console.warn("Image generation rate limit exceeded. Please wait a moment before trying again.");
            } else {
                console.error("Image API call failed:", error);
            }
            return null;
        }
    }
};

// --- NATIONAL SPIRIT DATA ---
const NATIONAL_SPIRITS = {
    strong_military_tradition: {
        name: "êµ³ê±´í•œ êµ°ì‚¬ ì „í†µ",
        description: "ê±°ë“­ëœ êµ°ì‚¬ì  ìŠ¹ë¦¬ë¡œ ì¸í•´ êµ°ì„ ì¤‘ì‹œí•˜ëŠ” ê°•ë ¥í•œ ì „í†µì´ í™•ë¦½ë˜ì—ˆìŠµë‹ˆë‹¤.",
        trigger: (tendencies) => tendencies.military >= 3 && tendencies.aggressive >= 2,
        effects: { positive: ["ì‹ ê·œ ì¥êµ° ê²½í—˜ì¹˜ +10"], negative: ["ì™¸êµ í™œë™ ì‹œ ìš°í˜¸ë„ íšë“ -5%"], stats: { manpower_bonus: 10000, politicalPower_penalty: -5 } }
    },
    reliance_on_foreign_powers: {
        name: "ì™¸ì„¸ ì˜ì¡´ ì •ì±…",
        description: "ì™¸êµì™€ ë™ë§¹ì— ë°˜ë³µì ìœ¼ë¡œ ì˜ì¡´í•˜ì—¬, êµ­ê°€ì˜ ì •ì±…ì´ ì™¸ì„¸ì— ì‰½ê²Œ íœ˜ë‘˜ë¦¬ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.",
        trigger: (tendencies) => tendencies.diplomacy >= 4,
        effects: { positive: ["ë™ë§¹êµ­ê³¼ì˜ ê´€ê³„ ê°œì„  +15%"], negative: ["êµ­ê°€ ì•ˆì •ë„ -5"], stats: { stability_penalty: -5 } }
    },
    veteran_officer_corps: {
        name: "ë…¸ë ¨í•œ ì¥êµë‹¨",
        description: "ìˆ˜ë§ì€ ì „ìŸì„ ê±°ì¹˜ë©° ë‹¨ë ¨ëœ ì¥êµë‹¨ì´ ê°•ë ¥í•œ ì§€íœ˜ ì²´ê³„ë¥¼ í˜•ì„±í–ˆìŠµë‹ˆë‹¤.",
        trigger: (tendencies) => tendencies.military >= 5,
        effects: { 
            positive: ["ê°€ìš© ì¸ë ¥ +15,000"], 
            negative: ["ê¶Œë ¥ íšë“ì— ì†Œí­ í˜ë„í‹°"], 
            stats: { manpower_bonus: 15000, politicalPower_penalty: -5 } 
        }
    },
    military_overreach: {
        name: "êµ°ì˜ ê³¼ë„í•œ ì˜í–¥ë ¥",
        description: "êµ°ì˜ ê¶Œë ¥ì´ ê³¼ë„í•˜ê²Œ ì»¤ì ¸ ì •ë¶€ì˜ í†µì œë ¥ì´ ì•½í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì¿ ë°íƒ€ì˜ ìœ„í—˜ì´ ê°ì§€ë©ë‹ˆë‹¤.",
        trigger: (tendencies, state) => tendencies.military >= 5 && state.playerNation.stability < 40,
        effects: { 
            positive: [], 
            negative: ["ê¶Œë ¥ íšë“ëŸ‰ -10", "êµ­ê°€ ì•ˆì •ë„ -5"], 
            stats: { politicalPower_penalty: -10, stability_penalty: -5 } 
        }
    },
    bureaucracy_established: {
        name: "ê´€ë£Œì œ í™•ë¦½",
        description: "ì˜ ì •ë¹„ëœ í–‰ì • ì²´ê³„ ë•ë¶„ì— êµ­ê°€ê°€ íš¨ìœ¨ì ìœ¼ë¡œ ìš´ì˜ë©ë‹ˆë‹¤.",
        trigger: (tendencies) => tendencies.internal >= 5,
        effects: { 
            positive: ["ê¶Œë ¥ íšë“ëŸ‰ +10", "ì§€ì§€ë„ +5"], 
            negative: [], 
            stats: { politicalPower_bonus: 10, approval_bonus: 5 } 
        }
    },
    corrupt_government: {
        name: "ë¶€íŒ¨í•œ ì •ë¶€",
        description: "ê´€ë¦¬ë“¤ì˜ ë¶€íŒ¨ì™€ ë¬´ëŠ¥ìœ¼ë¡œ í–‰ì • ê¸°ëŠ¥ì´ ë§ˆë¹„ë˜ê³  êµ­ë¯¼ì˜ ì‹ ë¢°ë¥¼ ìƒì—ˆìŠµë‹ˆë‹¤.",
        trigger: (tendencies, state) => state.playerNation.stability < 30 && state.playerNation.approval < 30,
        effects: { 
            positive: [], 
            negative: ["ê¶Œë ¥ íšë“ëŸ‰ -15", "êµ­ê°€ ì•ˆì •ë„ -10"], 
            stats: { politicalPower_penalty: -15, stability_penalty: -10 } 
        }
    },
    golden_age_of_arts: {
        name: "ì˜ˆìˆ  í™©ê¸ˆê¸°",
        description: "ë¬¸í™”ì™€ ì˜ˆìˆ ì´ ì „ì„±ê¸°ë¥¼ ë§ì´í•˜ì—¬ êµ­ë¯¼ì˜ ìê¸ì‹¬ì„ ê³ ì·¨ì‹œí‚¤ê³  ìˆìŠµë‹ˆë‹¤.",
        trigger: (tendencies) => tendencies.economy >= 4 && tendencies.internal >= 4,
        effects: { 
            positive: ["ì§€ì§€ë„ +10", "ê¶Œë ¥ +5"], 
            negative: [], 
            stats: { approval_bonus: 10, politicalPower_bonus: 5 } 
        }
    },
    rise_of_nationalism: {
        name: "ë¯¼ì¡±ì£¼ì˜ ê³ ì–‘",
        description: "ê°•ë ¥í•œ ë¯¼ì¡±ì£¼ì˜ ì‚¬ìƒì´ êµ­ë¯¼ì„ í•˜ë‚˜ë¡œ ë¬¶ê³  ìˆìœ¼ë‚˜, ì£¼ë³€êµ­ê³¼ì˜ ê°ˆë“±ì„ ìœ ë°œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
        trigger: (tendencies) => tendencies.aggressive >= 4 && tendencies.internal >= 3,
        effects: { 
            positive: ["ìµœëŒ€ ì¸ë ¥ +5%", "ì•ˆì •ë„ +5"], 
            negative: ["ì™¸êµ ê´€ê³„ ì•…í™” ê°€ëŠ¥ì„±"], 
            stats: { manpower_max_bonus: 5, stability_bonus: 5 } 
        }
    }
};


// --- CORE GAME ENGINE ---
const game = {
    state: {},
    selectedAdvisors: new Set(),
    newProposals: [],
    isRegenerating: false,
    advisorConversationTextHistory: "",
    
    /**
     * Initializes the game with a specific scenario.
     * @param {string} scenarioId - The ID of the scenario to load.
     */
    init(scenarioId) {
        if (!Scenarios[scenarioId]) {
            showInfoModal("ì‹œë‚˜ë¦¬ì˜¤ ì˜¤ë¥˜", `ì˜¤ë¥˜: ì‹œë‚˜ë¦¬ì˜¤ '${scenarioId}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`); return;
        }
        this.state = JSON.parse(JSON.stringify(Scenarios[scenarioId].initialState));
        
        // Initialize game state properties if they don't exist
        this.state.nationalSpirits = this.state.nationalSpirits || [];
        this.state.tendencies = { military: 0, diplomacy: 0, aggressive: 0, cautious: 0, economy: 0, internal: 0 };
        this.state.absurdityCounter = 0;
        this.state.playerNation.powerInfluence = this.state.playerNation.powerInfluence || 75;
        this.state.playerNation.income = this.state.playerNation.income || { treasury: 10, manpower: 5, resources: 1 };
        this.state.playerNation.fatigue = 0;
        this.state.world.isEmergency = false;
        this.state.research = this.state.research || { currentProject: null, progress: 0, timeElapsed: 0 };



        // Reset dynamic data
        this.state.world.lastImageDescription = null;
        this.isRegenerating = false;
        this.advisorConversationTextHistory = "";
        if (this.state.advisors) {
            this.state.advisors.forEach(a => a.imageUrl = null);
        }
        
        // Prepare initial event
        const initialEvent = JSON.parse(JSON.stringify(Scenarios[scenarioId].initialEvent));
        initialEvent.baseChoices = [...initialEvent.choices];
        initialEvent.choices = initialEvent.choices.map(c => {
            const choiceId = c.id;
            const fullChoice = { ...c, execute: this.handleStandardChoice.bind(this) };
            if (!Choices[choiceId]) {
                Choices[choiceId] = fullChoice;
            }
            return fullChoice;
        });
        Events[this.state.world.currentEvent] = initialEvent;

        this.update(null);
    },

    /**
     * The main game loop. Processes player choice, updates state, and renders the new state.
     * @param {object|null} playerChoice - The choice object selected by the player. Null for the initial call.
     */
    async update(playerChoice) {
        if (playerChoice) {
             if (useFatigueSystem) {
                const now = new Date(this.state.world.date);
                const currentHour = now.getHours();
                const isWorkingHours = currentHour >= 9 && currentHour < 19;

                if (!isWorkingHours && !this.state.world.isEmergency) {
                    openActionConfirmModal(playerChoice);
                    return; // Stop further processing until user decides
                }
            }
            // If fatigue system is off, or it's working hours, or it's an emergency, proceed.
            const timeToAdvance = estimateTimeForAction(playerChoice.text);
            advanceTimeAndAnimate(timeToAdvance, async () => {
                await this.processTurn(playerChoice);
            });
        } else {
             // Initial setup, no time advance
             this.Renderer.renderAll();
        }
    },

    async processTurn(playerChoice) {
        // Reset UI elements for the new turn
        document.getElementById('advisor-discussion-container').classList.add('hidden');
        document.getElementById('advisor-discussion-log').innerHTML = '';
        this.newProposals = [];

        await this.updateTendencies(playerChoice.text);
        
        // NEW: Check for triggered events
        const triggeredEvent = this.checkTriggeredEvents();
        if (triggeredEvent) {
            // A special event overrides the player's choice!
            Events[triggeredEvent.id] = triggeredEvent;
            this.state.world.currentEvent = triggeredEvent.id;
            openReportModal("ê¸´ê¸‰ ìƒí™©!", `ë‹¹ì‹ ì˜ í–‰ë™ê³¼ ê´€ê³„ì—†ì´ ê¸´ê¸‰í•œ ìƒí™©ì´ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${triggeredEvent.narrative}`);
        } else {
            // No triggered event, proceed as normal
            const choiceLogic = Choices[playerChoice.id] || playerChoice;
            if (choiceLogic && typeof choiceLogic.execute === 'function') {
                await choiceLogic.execute(this.state, choiceLogic);
            } else {
                console.error(`Choice logic for '${playerChoice.id}' not found or not executable.`);
            }
        }
        
        this.checkNationalSpiritFormation();
        this.Renderer.renderAll();
    },

    
    /**
     * Asks the Gemini API to categorize a choice text and updates player tendencies.
     * @param {string} text - The text of the player's chosen option.
     */
    async updateTendencies(text) {
        const tags = await this.getTendencyTagsFromChoice(text);
        if (tags.length > 0) {
            tags.forEach(tag => {
                if (this.state.tendencies.hasOwnProperty(tag)) {
                    this.state.tendencies[tag]++;
                    console.log(`Tendency updated: ${tag} = ${this.state.tendencies[tag]}`);
                }
            });
        }
    },
    
    /**
     * Uses the Gemini API to get tendency tags from a choice's text.
     * @param {string} choiceText - The text to analyze.
     * @returns {Promise<string[]>} An array of tendency tags.
     */
    async getTendencyTagsFromChoice(choiceText) {
        const systemPrompt = `You are a game system analyzer. Categorize the player's choice into one or more keywords from this list: [military, diplomacy, aggressive, cautious, economy, internal]. Respond with only a comma-separated list. For example: military, aggressive`;
        const userPrompt = `Player's choice: "${choiceText}"`;
        try {
            const response = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
            if (response) {
                return response.split(',').map(tag => tag.trim().toLowerCase());
            }
        } catch (e) {
            console.error("Failed to get tendency tags:", e);
        }
        return [];
    },
    
    checkTriggeredEvents() {
        // Faction Rebellion Check
        for (const faction of this.state.internalFactions) {
            if (faction.loyalty < 20) {
                // Trigger a rebellion!
                faction.loyalty = 50; // Reset loyalty
                this.applyEffects([
                    {"type": "RESOURCE", "resource": "stability", "change": -20},
                    {"type": "RESOURCE", "resource": "manpower", "change": -50000} // Example penalty
                ]);
                
                const newEvent = {
                    id: 'event_rebellion_' + faction.id,
                    narrative: `[${faction.name}] ì„¸ë ¥ì´ ë‹¹ì‹ ì˜ í†µì¹˜ì— ë°˜ë°œí•˜ì—¬ ë°˜ë€ì„ ì¼ìœ¼ì¼°ìŠµë‹ˆë‹¤! ì´ë“¤ì˜ ë¶ˆë§Œì„ ë¬´ì‹œí•œ ëŒ€ê°€ë¡œ êµ­ê°€ ì•ˆì •ë„ê°€ í¬ê²Œ í•˜ë½í•˜ê³  ë³‘ë ¥ì„ ìƒìŠµë‹ˆë‹¤.`,
                    prompt: "ë°˜ë€ì„ ì–´ë–»ê²Œ ì§„ì••í•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                    choices: [
                        { id: `rebel_1_${faction.id}`, text: "êµ°ëŒ€ë¥¼ ë³´ë‚´ ë¬´ë ¥ìœ¼ë¡œ ì§„ì••í•œë‹¤.", description: "ì§ˆì„œë¥¼ íšŒë³µí•˜ì§€ë§Œ, ë” í° ë¶ˆì”¨ë¥¼ ë‚¨ê¸¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.", execute: this.handleStandardChoice.bind(this) },
                        { id: `rebel_2_${faction.id}`, text: "í˜‘ìƒë‹¨ì„ ë³´ë‚´ ìš”êµ¬ë¥¼ ë“¤ì–´ì¤€ë‹¤.", description: "êµ­ê³ ë¥¼ ì†Œëª¨í•˜ì—¬ ë°˜ë€ì„ ë¬´ë§ˆí•©ë‹ˆë‹¤.", execute: this.handleStandardChoice.bind(this) }
                    ],
                    baseChoices: []
                };
                newEvent.baseChoices = [...newEvent.choices];
                return newEvent;
            }
        }
        return null; // No event triggered
    },

    /**
     * Checks if any new National Spirits should be formed based on player tendencies.
     */
    checkNationalSpiritFormation() {
        for (const spiritId in NATIONAL_SPIRITS) {
            if (this.state.nationalSpirits.includes(spiritId)) continue;

            const spirit = NATIONAL_SPIRITS[spiritId];
            if (spirit.trigger(this.state.tendencies, this.state)) {
                this.state.nationalSpirits.push(spiritId);
                let effectsHtml = '<ul>';
                 (spirit.effects.positive || []).forEach(e => effectsHtml += `<li class='text-green-400'>+ ${e}</li>`);
                 (spirit.effects.negative || []).forEach(e => effectsHtml += `<li class='text-red-400'>- ${e}</li>`);
                effectsHtml += '</ul>';

                openReportModal(
                    "ìƒˆë¡œìš´ êµ­ê°€ ì •ì‹  í˜•ì„±",
                    `ë‹¹ì‹ ì˜ ê²°ì •ë“¤ì€ êµ­ê°€ì˜ ìƒˆë¡œìš´ ì •ì²´ì„±ì„ ë§Œë“¤ì–´ëƒˆìŠµë‹ˆë‹¤: <br><br><strong class="text-yellow-300 text-lg">[${spirit.name}]</strong><br><p class="mt-2 text-gray-400">${spirit.description}</p><div class='mt-4'>${effectsHtml}</div>`
                );
            }
        }
    },

    /**
     * Handles a standard player choice by generating the next game event via the Gemini API.
     * @param {object} currentState - The current game state.
     *@param {object} playerChoice - The choice object selected by the player.
     */
    async handleStandardChoice(currentState, playerChoice) {
        const systemPrompt = `You are a game master for 'The Sovereign's Chronicle'. Your role is to create a challenging and realistic experience based on these core mechanics:
1.  **Treasury (êµ­ê³ ) is Fuel:** Almost all significant actions (military, research, diplomacy) cost \`treasury\`. Choices must often reflect a cost.
2.  **The Core Dilemma:** Players face a constant choice between investing in the future (like research, which improves \`techLevel\`) and securing the present (like military, which affects battle outcomes).
3.  **Time is a Constraint:** Actions take time, meaning a choice for one path delays the other.
4.  **Stability (ì•ˆì •ë„) is Feedback:** The player's success or failure is reflected in \`stability\`. Military victories, successful research, and popular policies increase it. Defeats, internal strife, and resource shortages decrease it. Low stability can lead to negative events like rebellions.
5.  **(If active) Fatigue System:** The leader's fatigue impacts their effectiveness. High fatigue might lead to poor outcomes or dialogue reflecting their exhaustion.

Generate the next event IN KOREAN based on the player's choice. Follow these rules strictly:
-   **Reflect Game State:** The narrative MUST reflect the current state (factions, stability, leader's fatigue, research status, etc.).
-   **Create Dilemmas:** Create choices that present a clear dilemma (e.g., spend money now on troops vs. save for a long-term project).
-   **Strict Response Format:** Respond with ONLY the following sections, separated by '---':
    NARRATIVE: [A compelling story of what happens next.]
    ---
    PROMPT: [A new question for the player.]
    ---
    CHOICE 1: [Text for the first new choice.]
    ---
    CHOICE 2: [Text for the second new choice.]
    ---
    CHOICE 3: [Text for a third new choice (optional).]
    ---
    EFFECTS: [A valid JSON array of game state changes. For effects of type "NEW_LEADER_TRAIT", the trait's 'effects' object MUST ONLY use keys from this list: [stability, approval, politicalPower, treasury, manpower, resources, techLevel, powerInfluence]. For "START_RESEARCH", provide a 'project' object with 'id', 'name', 'description', 'totalTime' (in hours), 'cost', and 'effects' (applied on completion). Examples: {"type": "INTERNAL_FACTION_LOYALTY", "factionId": "nobility", "change": -5}, {"type": "RESOURCE", "resource": "treasury", "change": -500}, {"type": "START_RESEARCH", "project": {"id": "cannon_research", "name": "ëŒ€í¬ ì—°êµ¬", "description": "...", "totalTime": 720, "cost": 150, "effects": [{"type": "RESOURCE", "resource": "techLevel", "change": 1}]}}]`;
        
        const factionInfo = (currentState.factions || []).map(f => `${f.name}(${f.status}, ê´€ê³„ ${f.relationship})`).join(', ');
        const internalFactionInfo = (currentState.internalFactions || []).map(f => `${f.name}(ì¶©ì„±ë„ ${f.loyalty})`).join(', ');
        
        let fatigueContext = '';
        if (useFatigueSystem && currentState.playerNation.fatigue > 50) {
            fatigueContext = `- Leader's Fatigue: ${currentState.playerNation.fatigue.toFixed(0)}% (High - This should affect the narrative, showing signs of exhaustion or poor judgment).\n`;
        }
        
        let researchContext = 'í˜„ì¬ ì§„í–‰ì¤‘ì¸ ì—°êµ¬ ì—†ìŒ.';
        if (currentState.research && currentState.research.currentProject) {
            researchContext = `í˜„ì¬ [${currentState.research.currentProject.name}] ì—°êµ¬ ì§„í–‰ ì¤‘ (${currentState.research.progress.toFixed(0)}% ì™„ë£Œ).`;
        }

        const userPrompt = `CURRENT STATE for ${currentState.playerNation.name} in ${new Date(currentState.world.date).getFullYear()}:\n` +
            `- Stability: ${currentState.playerNation.stability}, Treasury: ${currentState.playerNation.treasury}\n`+
            fatigueContext +
            `- Current Research: ${researchContext}\n` +
            `- Foreign Factions: ${factionInfo}\n` +
            `- Internal Factions: ${internalFactionInfo}\n` +
            `PLAYER'S CHOICE: "${playerChoice.text}"\n` +
            'Generate the next event, narrative, choices, and a JSON array for EFFECTS that reflects the game mechanics.';
        
        const responseText = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
        if (!responseText) {
            showInfoModal("ì§„í–‰ ë¶ˆê°€", "AIê°€ ë‹¤ìŒ ì´ì•¼ê¸°ë¥¼ ë§Œë“œëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
            return;
        }

        const newEvent = this.parseNarrativeResponse(responseText);
        if (!newEvent) {
            showInfoModal("ì§„í–‰ ë¶ˆê°€", "AIì˜ ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ ì´ì•¼ê¸°ë¥¼ ê³„ì†í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
            return;
        }

        Events[newEvent.id] = newEvent;
        currentState.world.currentEvent = newEvent.id;
    },

    /**
     * Parses the multi-part response from the Gemini API into a structured event object.
     * @param {string} text - The raw text response from the API.
     * @returns {object|null} A new event object or null if parsing fails.
     */
    parseNarrativeResponse(text) {
        try {
            const newEvent = { id: 'event_' + Date.now() + Math.random(), choices: [] };
            const effectsRegex = /EFFECTS:\s*(\[[\s\S]*\])/;
            const effectsMatch = text.match(effectsRegex);
            let effectsJson = [];

            if (effectsMatch && effectsMatch[1]) {
                try {
                    effectsJson = JSON.parse(effectsMatch[1]);
                    this.applyEffects(effectsJson);
                } catch (e) {
                    console.error("Failed to parse EFFECTS JSON:", e, "Raw JSON:", effectsMatch[1]);
                }
            }
            
            const cleanText = text.replace(effectsRegex, '');
            const sections = cleanText.split('---').map(s => s.trim());
            
            sections.forEach(section => {
                if (section.startsWith('NARRATIVE:')) newEvent.narrative = section.substring('NARRATIVE:'.length).trim();
                else if (section.startsWith('PROMPT:')) newEvent.prompt = section.substring('PROMPT:'.length).trim();
                else if (section.match(/^CHOICE\s*\d:/)) {
                    const choiceText = section.substring(section.indexOf(':') + 1).trim();
                    if (choiceText) {
                        const choiceId = `choice_${newEvent.id}_${newEvent.choices.length + 1}`;
                        const newChoice = { 
                            id: choiceId, 
                            text: choiceText, 
                            description: "AIê°€ ìƒì„±í•œ ë™ì  ì„ íƒì§€ì…ë‹ˆë‹¤.",
                            execute: this.handleStandardChoice.bind(this)
                        };
                        newEvent.choices.push(newChoice);
                        Choices[choiceId] = newChoice;
                    }
                }
            });

            if (!newEvent.narrative || !newEvent.prompt || newEvent.choices.length === 0) {
                console.error("Parsed event is missing required fields.", newEvent, "Raw text:", text);
                return null;
            }
            newEvent.baseChoices = [...newEvent.choices];
            return newEvent;
        } catch (e) {
            console.error("Failed to parse AI narrative response:", e, "Raw text:", text);
            return null;
        }
    },
    
    /**
     * Applies an array of effect objects to the current game state.
     * @param {object[]} effects - An array of effect objects from the API.
     */
    applyEffects(effects) {
        if (!Array.isArray(effects)) return;

        const influence = (this.state.playerNation.powerInfluence || 100) / 100;

        effects.forEach(effect => {
            try {
                // Apply power influence modifier
                if (effect.change && (effect.type === 'RESOURCE' || effect.type === 'INTERNAL_FACTION_LOYALTY')) {
                    if (effect.change > 0) { // Buffs are modified
                        effect.change = Math.floor(effect.change * influence);
                    }
                    // Penalties are not modified (they always hit full force)
                }

                switch(effect.type) {
                    case 'INTERNAL_FACTION_LOYALTY':
                        const faction = this.state.internalFactions.find(f => f.id === effect.factionId);
                        if(faction) {
                            faction.loyalty = Math.max(0, Math.min(100, faction.loyalty + effect.change));
                        }
                        break;
                    case 'RESOURCE':
                        if (this.state.playerNation.hasOwnProperty(effect.resource)) {
                            this.state.playerNation[effect.resource] += effect.change;
                        }
                        break;
                    case 'START_RESEARCH':
                        if (this.state.research.currentProject) {
                            openReportModal("ì—°êµ¬ ì§€ì—°", `[${this.state.research.currentProject.name}] ì—°êµ¬ê°€ ì´ë¯¸ ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤. ìƒˆë¡œìš´ ì—°êµ¬ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
                        } else {
                            this.state.research.currentProject = effect.project;
                            this.state.research.progress = 0;
                            this.state.research.timeElapsed = 0;
                            openReportModal("ì—°êµ¬ ì‹œì‘", `[${effect.project.name}] ì—°êµ¬ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. (ì˜ˆìƒ ì‹œê°„: ${effect.project.totalTime}ì‹œê°„)`);
                        }
                        break;
                    case 'NEW_LEADER_TRAIT':
                         if (effect.trait && !this.state.leaderTraits.some(t => t.id === effect.trait.id)) {
                             this.state.leaderTraits.push(effect.trait);
                             showInfoModal("ìƒˆë¡œìš´ ì§€ë„ì íŠ¹ì„±", `ë‹¹ì‹ ì€ '[${effect.trait.name}]' íŠ¹ì„±ì„ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
                         }
                        break;
                }
            } catch (e) {
                console.error("Error applying effect:", effect, e);
            }
        });
    },

    /**
     * Determines a context for the image generation prompt based on keywords in the narrative.
     * @param {string} narrative - The event narrative.
     * @returns {string} A context string for the prompt.
     */
    getImagePromptContext(narrative) {
        if (narrative.includes('í† ë¡ ') || narrative.includes('ì›ë¡œì›') || narrative.includes('íšŒì˜') || narrative.includes('ì¡°ì •') || narrative.includes('ì™¸êµ')) return "This is a political and diplomatic scene. Depict leaders and advisors in a tense discussion inside a historically accurate building like a senate, palace, or court. Focus on expressions and political intrigue, not combat.";
        if (narrative.includes('ì „ìŸ') || narrative.includes('êµ°ëŒ€') || narrative.includes('í•¨ëŒ€') || narrative.includes('ë³‘ë ¥') || narrative.includes('ì „íˆ¬') || narrative.includes('í•¨ë½')) return "This is a military scene. Depict armies preparing for battle, fleets on the sea, or a tense military standoff. Focus on the scale and tension of the forces involved.";
        if (narrative.includes('ë°±ì„±') || narrative.includes('ì‹œë¯¼') || narrative.includes('ì‹œì¥') || narrative.includes('ë„ì‹œ')) return "This is a social scene focusing on the populace. Depict citizens in a city square, marketplace, or reacting to events. Focus on the mood of the people and the daily life of the era.";
        return "This is a general historical scene. Interpret the narrative to create a compelling and accurate image.";
    },

    /**
     * The Renderer object handles all updates to the DOM.
     */
    Renderer: {
        async renderAll() {
            await this.renderNarrative();
            this.renderUIPanel();
            this.renderCollapsiblePanels();
            this.renderChoices();
        },
        async renderNarrative() {
            const narrativeContainer = document.getElementById('narrative-output');
            narrativeContainer.innerHTML = '';
            
            const event = Events[game.state.world.currentEvent];
            if (!event) {
                narrativeContainer.innerHTML = "<p>ì‚¬ê±´ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ì´ê±°ë‚˜ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</p>";
                document.getElementById('event-image-container').innerHTML = ''; 
                return;
            }

            this.generateAndDisplayImage();

            const speakerIcon = `<span onclick="playNarrativeAudio(this)" class="speaker-button" title="ë‚´ë ˆì´ì…˜ ë“£ê¸°"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg></span>`;
            let narrativeHtml = `<div><p id="narrative-text" class="inline">${event.narrative.replace(/\n/g, '<br>')}</p>${speakerIcon}</div>`;
            narrativeContainer.innerHTML = narrativeHtml;
        },

        async generateAndDisplayImage() {
            const imageContainer = document.getElementById('event-image-container');
            imageContainer.innerHTML = `<div class="text-center text-gray-500"><div class="spinner" style="margin: auto;"></div><p class="mt-2 text-sm">âœ¨ ì¥ë©´ ìƒì„± ì¤‘...</p></div>`;
            const event = Events[game.state.world.currentEvent];
            const nationName = game.state.playerNation.name;
            const keywords = HISTORICAL_KEYWORDS[nationName] || HISTORICAL_KEYWORDS['default'];
            const sceneContext = game.getImagePromptContext(event.narrative);
            let continuityPrompt = game.state.world.lastImageDescription ? `\n**PREVIOUS SCENE REFERENCE:** The previous image was described as: "${game.state.world.lastImageDescription}". Maintain a consistent art style, lighting, and mood unless the narrative indicates a major shift.` : "";
            
            let imagePrompt = 'Create a realistic, cinematic, historical painting for a text-adventure game. IMPORTANT: Do not write any words, letters, subtitles, or characters on the image itself. The image should be clean of any text.\n';
            imagePrompt += `**Primary Instruction:** ${sceneContext}\n`;
            imagePrompt += `**Narrative to Depict:** "${event.narrative}"\n`;
            imagePrompt += `**Setting:** ${nationName}, year ${new Date(game.state.world.date).getFullYear()}.\n`;
            imagePrompt += `**Key Theme:** ${event.prompt || "Historical Scene"}.\n`;
            imagePrompt += '**Artistic Constraints:**\n';
            imagePrompt += `* MUST Include: ${keywords.positive}.\n`;
            imagePrompt += `* MUST AVOID: ${keywords.negative}.`;
            imagePrompt += continuityPrompt;
            
            const imageUrl = await GEMINI.generateImage(imagePrompt);
            
            if (imageUrl) {
                imageContainer.innerHTML = `
                    <img src="${imageUrl}" alt="${event.prompt}" class="w-full h-full object-cover animate-fadeIn cursor-pointer" onclick="openImageModal(this.src)">
                    <button onclick="regenerateCurrentImage()" title="ë‹¤ë¥¸ ì´ë¯¸ì§€ ìƒì„±" class="absolute top-2 right-2 bg-black bg-opacity-50 text-white p-2 rounded-full hover:bg-opacity-75 transition">
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6"/><path d="M22 11.5A10 10 0 0 0 3.5 12.5"/><path d="M2 12.5a10 10 0 0 0 18.5-1"/></svg>
                    </button>`;
                if (!game.isRegenerating) {
                    game.state.world.lastImageDescription = `A ${sceneContext.toLowerCase()} in ${nationName} depicting: ${event.narrative}`;
                }
            } else {
                imageContainer.innerHTML = `<div class="w-full h-full flex items-center justify-center bg-gray-800 text-gray-500">ì¥ë©´ì„ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</div>
                <button onclick="regenerateCurrentImage()" title="ë‹¤ë¥¸ ì´ë¯¸ì§€ ìƒì„±" class="absolute top-2 right-2 bg-black bg-opacity-50 text-white p-2 rounded-full hover:bg-opacity-75 transition">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6M2.5 22v-6h6"/><path d="M22 11.5A10 10 0 0 0 3.5 12.5"/><path d="M2 12.5a10 10 0 0 0 18.5-1"/></svg>
                </button>`;
            }
             game.isRegenerating = false;
        },
        
        createStatTooltip(statLabel, statKey, unit = '', dynamicModifiers = []) {
            const baseStats = game.state.playerNation;
            if (baseStats[statKey] === undefined) return { finalValue: 0, tooltipHtml: '', modifier: 0 };

            const baseValue = baseStats[statKey];
            const baseModifiers = (baseStats.modifiers && baseStats.modifiers[statKey]) ? baseStats.modifiers[statKey] : [];
            const allGeneralModifiers = [...baseModifiers, ...dynamicModifiers];
            
            let spiritModifierValue = 0;
            let spiritModifierLines = [];

            (game.state.nationalSpirits || []).forEach(spiritId => {
                const spirit = NATIONAL_SPIRITS[spiritId];
                if (spirit && spirit.effects.stats) {
                    Object.keys(spirit.effects.stats).forEach(stat => {
                        if (stat.startsWith(statKey)) {
                            const value = spirit.effects.stats[stat];
                            if(typeof value === 'number'){
                                spiritModifierValue += value;
                                const color = value >= 0 ? 'text-green-400' : 'text-red-400';
                                const sign = value >= 0 ? '+' : '';
                                spiritModifierLines.push(`<li><span class='${color}'>${spirit.name}:</span> <span class='float-right ${color}'>${sign}${value}${unit}</span></li>`);
                            }
                        }
                    });
                }
            });


            let generalModifierValue = 0;
            let generalModifierLines = [];
            if (allGeneralModifiers.length > 0) {
                allGeneralModifiers.forEach(mod => {
                    generalModifierValue += mod.value;
                    const color = mod.value >= 0 ? 'text-green-400' : 'text-red-400';
                    const sign = mod.value >= 0 ? '+' : '';
                    generalModifierLines.push(`<li><span class='${color}'>${mod.name}:</span> <span class='float-right ${color}'>${sign}${mod.value.toLocaleString()}${unit}</span></li>`);
                });
            }

            let traitModifierValue = 0;
            let traitModifierLines = [];

            if (game.state.leaderTraits) {
                game.state.leaderTraits.forEach(trait => {
                    if (trait.effects) {
                        const effectKey = Object.keys(trait.effects).find(k => k.startsWith(statKey));
                        if (effectKey) {
                            const value = trait.effects[effectKey];
                            if (typeof value === 'number') {
                                traitModifierValue += value;
                                const color = value >= 0 ? 'text-green-400' : 'text-red-400';
                                const sign = value >= 0 ? '+' : '';
                                traitModifierLines.push(`<li><span class='${color}'>${trait.name}:</span> <span class='float-right ${color}'>${sign}${value.toLocaleString()}${unit}</span></li>`);
                            }
                        }
                    }
                });
            }
            
            let policyModifierValue = 0;
            let policyModifierLines = [];

            if (game.state.policies) {
                game.state.policies.filter(p => p.enacted).forEach(policy => {
                    if (policy.effects) {
                        const effectKey = Object.keys(policy.effects).find(k => k.startsWith(statKey) && (k.endsWith('_bonus') || k.endsWith('_penalty')));
                        if (effectKey) {
                            const value = policy.effects[effectKey];
                            policyModifierValue += value;
                            const color = value >= 0 ? 'text-green-400' : 'text-red-400';
                            const sign = value >= 0 ? '+' : '';
                            policyModifierLines.push(`<li><span class='${color}'>${policy.name}:</span> <span class='float-right ${color}'>${sign}${value.toLocaleString()}${unit}</span></li>`);
                        }
                    }
                });
            }

            const finalValue = baseValue + spiritModifierValue + generalModifierValue + traitModifierValue + policyModifierValue;
            const modifier = finalValue - baseValue;

            let tooltipHtml = `<strong class='text-yellow-300'>${statLabel} ìƒì„¸</strong><p class='text-xs my-1 text-gray-400'>${statLabel}ì— ëŒ€í•œ ì„¤ëª…ì…ë‹ˆë‹¤.</p><ul class='mt-2 space-y-1'>`;
            tooltipHtml += `<li>ê¸°ë³¸: <span class='float-right'>${(statKey === 'treasury' ? formatNumberWithKoreanUnits(baseValue) : (Math.floor(baseValue)).toLocaleString())}${unit}</span></li>`;
            
            if (generalModifierLines.length === 0 && spiritModifierLines.length === 0 && traitModifierLines.length === 0 && policyModifierLines.length === 0) {
                tooltipHtml += `<li><span class='text-gray-400'>ìˆ˜ì •ì¹˜ ì—†ìŒ</span></li>`;
            } else {
                tooltipHtml += generalModifierLines.join('');
                tooltipHtml += spiritModifierLines.join('');
                tooltipHtml += traitModifierLines.join('');
                tooltipHtml += policyModifierLines.join('');
            }
            
            if (statKey === 'techLevel') {
                const techName = TECH_LEVEL_NAMES[Math.min(finalValue, TECH_LEVEL_NAMES.length - 1)] || 'ë¯¸ì§€';
                tooltipHtml += `<li><span class='text-gray-400'>ë‹¨ê³„:</span> <span class='float-right text-cyan-400'>${techName}</span></li>`;
            }
             if (statKey === 'powerInfluence') {
                let desc = 'ê¼­ë‘ê°ì‹œ êµ°ì£¼';
                if (finalValue > 80) desc = 'ì ˆëŒ€ ê¶Œë ¥';
                else if (finalValue > 60) desc = 'ê³µê³ í•œ ê¶Œë ¥';
                else if (finalValue > 40) desc = 'ì•ˆì •ì ì¸ í†µì¹˜';
                else if (finalValue > 20) desc = 'ë¶ˆì•ˆì •í•œ ê¶Œìœ„';
                tooltipHtml += `<li><span class='text-gray-400'>ë‹¨ê³„:</span> <span class='float-right text-cyan-400'>${desc}</span></li>`;
            }

            tooltipHtml += `<hr class='border-gray-600 my-1'><li class='font-bold'>ìµœì¢… í•©ê³„: <span class='float-right'>${(statKey === 'treasury' ? formatNumberWithKoreanUnits(finalValue) : (Math.floor(finalValue)).toLocaleString())}${unit}</span></li></ul>`;

            return { finalValue, tooltipHtml, modifier };
        },

        renderUIPanel() {
            const uiContainer = document.getElementById('ui-panel-container');
            const baseStats = game.state.playerNation;
            if (!baseStats) return;

            const currencyPrefix = getCurrencySymbol(game.state.world.date, game.state.playerNation.name);

            let factionLoyaltyModifiers = [];
            if (game.state.internalFactions) {
                const enactedPolicies = game.state.policies.filter(p => p.enacted);
                game.state.internalFactions.forEach(faction => {
                    let finalLoyalty = faction.loyalty || 50;
                    enactedPolicies.forEach(policy => {
                        if (policy.effects) {
                            const bonusKey = `${faction.id}_loyalty_bonus`;
                            const penaltyKey = `${faction.id}_loyalty_penalty`;
                            if (policy.effects[bonusKey]) finalLoyalty += policy.effects[bonusKey];
                            if (policy.effects[penaltyKey]) finalLoyalty += policy.effects[penaltyKey];
                        }
                    });
                    finalLoyalty = Math.max(0, Math.min(100, finalLoyalty));

                    if (finalLoyalty < 35) {
                        const penalty = -Math.ceil((faction.influence || 0) / 10);
                        factionLoyaltyModifiers.push({ name: `${faction.name} ë¶ˆë§Œ`, value: penalty });
                    }
                });
            }
            
            const stabilityData = this.createStatTooltip('êµ­ê°€ ì•ˆì •ë„', 'stability', '%', factionLoyaltyModifiers);

            let dynamicModifiers = {};
            if (stabilityData.finalValue < 40) {
                dynamicModifiers.approval = [{ name: 'êµ­ê°€ ë¶ˆì•ˆ', value: -10 }];
                dynamicModifiers.politicalPower = [{ name: 'ì •ì¹˜ì  í˜¼ë€', value: -5 }];
            }

            const approvalData = this.createStatTooltip('ì§€ì§€ë„', 'approval', '%', dynamicModifiers.approval);
            const politicalPowerData = this.createStatTooltip('ê¶Œë ¥', 'politicalPower', '', dynamicModifiers.politicalPower);
            const treasuryData = this.createStatTooltip('êµ­ê³ ', 'treasury');
            const manpowerData = this.createStatTooltip('ê°€ìš© ì¸ë ¥', 'manpower');
            const resourcesData = this.createStatTooltip('êµ­ê°€ ìì›', 'resources');
            const techLevelData = this.createStatTooltip('ê¸°ìˆ  ìˆ˜ì¤€', 'techLevel');
            const powerInfluenceData = this.createStatTooltip('ê¶Œë ¥ ì˜í–¥ë ¥', 'powerInfluence', '%');

            
            const createDisplayString = (data, statKey, unit = '', prefix = '') => {
                let modifierText = '';
                if (data.modifier !== 0) {
                    const sign = data.modifier > 0 ? '+' : '';
                    const color = data.modifier > 0 ? 'text-green-400' : 'text-red-400';
                    const modifierUnit = (statKey === 'techLevel' || statKey === 'treasury') ? '' : unit;
                    const modifierDisplay = (statKey === 'treasury') ? formatNumberWithKoreanUnits(data.modifier) : Math.floor(data.modifier).toLocaleString();
                    modifierText = ` <span class="text-xs ${color}">(${sign}${modifierDisplay}${modifierUnit})</span>`;
                }
                if (statKey === 'techLevel') {
                    const techName = TECH_LEVEL_NAMES[Math.min(Math.floor(data.finalValue), TECH_LEVEL_NAMES.length - 1)] || 'ë¯¸ì§€';
                    return `${prefix}${Math.floor(data.finalValue).toLocaleString()}${unit} <span class="text-xs text-gray-400">(${techName})</span>${modifierText}`;
                }
                const finalValueDisplay = (statKey === 'treasury') ? formatNumberWithKoreanUnits(data.finalValue) : Math.floor(data.finalValue).toLocaleString();
                const finalUnit = (statKey === 'treasury') ? '' : unit;
               return `${prefix}${finalValueDisplay}${finalUnit}${modifierText}`;
            };
            
            const panelData = {
                stability: { data: stabilityData, config: { label: 'êµ­ê°€ ì•ˆì •ë„', unit: '%', color: 'text-blue-400' } },
                approval: { data: approvalData, config: { label: 'ì§€ì§€ë„', unit: '%', color: 'text-pink-400' } },
                politicalPower: { data: politicalPowerData, config: { label: 'ê¶Œë ¥', unit: '', color: 'text-purple-400' } },
                treasury: { data: treasuryData, config: { label: 'êµ­ê³ ', unit: '', prefix: currencyPrefix + ' ', color: 'text-green-500' } },
                manpower: { data: manpowerData, config: { label: 'ê°€ìš© ì¸ë ¥', unit: 'M', color: 'text-green-400' } },
                resources: { data: resourcesData, config: { label: 'êµ­ê°€ ìì›', unit: '', color: 'text-yellow-500' } },
                techLevel: { data: techLevelData, config: { label: 'ê¸°ìˆ  ìˆ˜ì¤€', unit: '', color: 'text-cyan-400', prefix: 'Lv.' } },
                powerInfluence: { data: powerInfluenceData, config: { label: 'ê¶Œë ¥ ì˜í–¥ë ¥', unit: '%', color: 'text-red-400' } },
            };

            let panelHtml = '<div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-center">';
            
            for (const [statKey, item] of Object.entries(panelData)) {
                let displayValue;
                if (statKey === 'manpower') {
                    const data = item.data;
                    const modifierText = data.modifier !== 0 ? ` <span class="text-xs ${data.modifier > 0 ? 'text-green-400' : 'text-red-400'}">(${data.modifier > 0 ? '+' : ''}${(data.modifier/1000000).toFixed(2)}M)</span>` : '';
                    displayValue = `${(data.finalValue / 1000000).toFixed(2)}M${modifierText}`;
                } else {
                    displayValue = createDisplayString(item.data, statKey, item.config.unit, item.config.prefix);
                }
                panelHtml += this.createPanelItem(item.config.label, displayValue, item.config.color, item.data.tooltipHtml);
            }
            
            panelHtml += '</div>';
            uiContainer.innerHTML = panelHtml;
        },

        renderCollapsiblePanels() {
            this.renderCollapsiblePanel('time-panel-container', 'í˜„ì¬ ì‹œê°', game.state, this.getTimePanelHtml);
            this.renderCollapsiblePanel('research-panel-container', 'ì—°êµ¬', game.state.research, this.getResearchPanelHtml);
            this.renderCollapsiblePanel('national-spirits-container', 'êµ­ê°€ ì •ì‹ ', game.state.nationalSpirits, this.getNationalSpiritsHtml);
            this.renderCollapsiblePanel('internal-factions-container', 'ë‚´ë¶€ ì„¸ë ¥', game.state.internalFactions, this.getInternalFactionsHtml);
            this.renderCollapsiblePanel('factions-container', 'ì£¼ë³€ êµ­ê°€', game.state.factions, this.getExternalFactionsHtml);
            this.renderCollapsiblePanel('leader-traits-container', 'ì§€ë„ì íŠ¹ì„±', game.state.leaderTraits, this.getLeaderTraitsHtml);
        },
        
        getResearchPanelHtml(researchState) {
            if (!researchState) return '<p class="text-center text-gray-500">ì—°êµ¬ ì •ë³´ ì—†ìŒ.</p>';
            
            if (!researchState.currentProject) {
                return `<div class="text-center">
                            <p class="text-gray-500">í˜„ì¬ ì§„í–‰ ì¤‘ì¸ ì—°êµ¬ê°€ ì—†ìŠµë‹ˆë‹¤.</p>
                            <button onclick="getResearchRecommendation()" class="mt-3 px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white text-sm font-bold rounded-md transition-all">
                                âš¡ ì—°êµ¬ ì œì•ˆ ë°›ê¸°
                            </button>
                        </div>`;
            }

            const progress = researchState.progress || 0;
            const projectName = researchState.currentProject.name;
            const gradientColor = `linear-gradient(to right, #60a5fa, #3b82f6, #1d4ed8)`;

            return `
                 <div class="font-mono text-sm">
                    <div class="flex justify-between items-center mb-2">
                         <div>
                            <span class="font-bold">ì—°êµ¬: <span class="text-blue-300">${projectName}</span></span>
                            <span class="ml-4 px-2 py-1 text-xs font-semibold text-white bg-blue-600 rounded-full">ì§„í–‰ì¤‘</span>
                        </div>
                        <span class="font-mono text-gray-300">${progress.toFixed(0)}%</span>
                    </div>
                    <div class="w-full bg-gray-700 rounded-full h-2.5">
                        <div class="bg-blue-500 h-2.5 rounded-full" style="width: ${progress}%; background: ${gradientColor}; transition: width 0.5s ease-in-out;"></div>
                    </div>
                </div>`;
        },

        getTimePanelHtml(state) {
            if (!state || !state.world || !state.world.date) return '';
            const dateObj = new Date(state.world.date);
            const dateString = formatHistoricalDate(state.world.date);
            const timeString = dateObj.toTimeString().split(' ')[0];

            let fatigueHtml = '';
            if (useFatigueSystem) {
                const fatigue = state.playerNation.fatigue || 0;
                let statusText, statusColor, workStatus, workStatusColor, emergencyText = '';

                if (fatigue < 25) { statusText = 'ì–‘í˜¸'; statusColor = 'text-green-400'; }
                else if (fatigue < 50) { statusText = 'ë³´í†µ í”¼ë¡œ'; statusColor = 'text-yellow-400'; }
                else if (fatigue < 75) { statusText = 'ë†’ì€ í”¼ë¡œ'; statusColor = 'text-orange-400'; }
                else { statusText = 'ê·¹ì‹¬í•œ í”¼ë¡œ'; statusColor = 'text-red-500'; }

                const currentHour = dateObj.getHours();
                if (state.world.isEmergency) {
                    workStatus = 'ë¹„ìƒì‚¬íƒœ'; workStatusColor = 'bg-red-600';
                    emergencyText = `<p class="text-xs text-red-400 mt-1 animate-pulse">ë°¤ìƒ˜ ê·¼ë¬´ë¡œ ê±´ê°•ì´ ì•…í™”ë˜ê³  ìˆìŠµë‹ˆë‹¤.</p>`;
                } else if (currentHour >= 9 && currentHour < 19) {
                    workStatus = 'ê·¼ë¬´ì¤‘'; workStatusColor = 'bg-green-600';
                } else {
                    workStatus = 'ë¹„ê·¼ë¬´ì‹œê°„'; workStatusColor = 'bg-gray-500';
                }

                const gradientColor = `linear-gradient(to right, #4ade80, #facc15, #f97316, #ef4444)`;

                fatigueHtml = `
                    <div class="mt-4 pt-4 border-t border-gray-700 text-sm">
                        <div class="flex justify-between items-center mb-2">
                             <div>
                                <span class="font-bold">ê±´ê°• ìƒíƒœ: <span class="${statusColor}">${statusText}</span></span>
                                <span class="ml-4 px-2 py-1 text-xs font-semibold text-white ${workStatusColor} rounded-full">${workStatus}</span>
                            </div>
                            <span class="font-mono text-gray-300">${fatigue.toFixed(0)}%</span>
                        </div>
                        <div class="w-full bg-gray-700 rounded-full h-2.5">
                            <div class="h-2.5 rounded-full" style="width: ${fatigue}%; background: ${gradientColor}; transition: width 0.5s ease-in-out;"></div>
                        </div>
                        ${emergencyText}
                    </div>
                `;
            }

            return `<div class="font-mono">
                        <div class="text-center text-xl tracking-wider">
                            <span id="time-panel-date">${dateString}</span>
                            <span id="time-panel-time" class="ml-4 text-yellow-300">${timeString}</span>
                        </div>
                        ${fatigueHtml}
                    </div>`;
        },

        renderCollapsiblePanel(containerId, title, data, renderer) {
            const container = document.getElementById(containerId);
            
            if (containerId === 'research-panel-container') {
                // ì—°êµ¬ íŒ¨ë„ì€ í•­ìƒ í‘œì‹œ, dataëŠ” game.state.research ê°ì²´ì„
            } else if (!data || (Array.isArray(data) && data.length === 0)) {
                // ì‹œê°„ íŒ¨ë„ ì™¸ì˜ ë¹ˆ ë°°ì—´ ë°ì´í„°ëŠ” ë Œë”ë§ ì•ˆ í•¨
                if(containerId !== 'time-panel-container') {
                     container.innerHTML = ''; return;
                }
            }
             const icons = {
                 'í˜„ì¬ ì‹œê°': `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71z"/><path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0"/></svg>`,
                 'ì—°êµ¬': `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 4.754a3.246 3.246 0 1 0 0 6.492 3.246 3.246 0 0 0 0-6.492zM5.754 8a2.246 2.246 0 1 1 4.492 0 2.246 2.246 0 0 1-4.492 0z"/><path d="M9.796 1.343c-.527-1.79-3.065-1.79-3.592 0l-.094.319a.873.873 0 0 1-1.255.52l-.292-.16c-1.64-.892-3.433.902-2.54 2.541l.159.292a.873.873 0 0 1-.52 1.255l-.319.094c-1.79.527-1.79 3.065 0 3.592l.319.094a.873.873 0 0 1 .52 1.255l-.16.292c-.892 1.64.901 3.434 2.541 2.54l.292-.159a.873.873 0 0 1 1.255.52l.094.319c.527 1.79 3.065 1.79 3.592 0l.094-.319a.873.873 0 0 1 1.255-.52l.292.16c1.64.893 3.434-.901 2.54-2.541l-.159-.292a.873.873 0 0 1 .52-1.255l.319-.094c1.79-.527 1.79-3.065 0-3.592l-.319-.094a.873.873 0 0 1-.52-1.255l.16-.292c.893-1.64-.902-3.433-2.541-2.54l-.292.16a.873.873 0 0 1-1.255-.52l-.094-.319z"/></svg>`,
                 'êµ­ê°€ ì •ì‹ ': `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M14.778.085A.5.5 0 0 1 15 .5V8a.5.5 0 0 1-.314.464L14.5 8l.186.464A.5.5 0 0 1 14.5 9v7a.5.5 0 0 1-.722.454L13 16.01l-.278.454A.5.5 0 0 1 12.5 16h-11a.5.5 0 0 1-.454-.722L1 15.01l-.454-.278A.5.5 0 0 1 0 14.5v-13a.5.5 0 0 1 .278-.454L1 .01l.222-.454A.5.5 0 0 1 1.5 0h13.278zM1.5 14.722L1 14.5V1.5L1.5 1.28l.222.454L2.5 2h11v12h-11l.722.454-.222.454zM2 2.5a.5.5 0 0 1 .5-.5h10a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-10a.5.5 0 0 1-.5-.5v-11z"/></svg>`,
                 'ë‚´ë¶€ ì„¸ë ¥': `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7 14s-1 0-1-1 1-4 5-4 5 3 5 4-1 1-1 1zm4-6a3 3 0 1 0 0-6 3 3 0 0 0 0 6m-5.784 6A2.238 2.238 0 0 1 5 13c0-1.355.68-2.75 1.936-3.72A6.325 6.325 0 0 0 5 9c-4 0-5 3-5 4s1 1 1 1zM4.5 8a2.5 2.5 0 1 0 0-5 2.5 2.5 0 0 0 0 5"/></svg>`,
                 'ì£¼ë³€ êµ­ê°€': `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0zM1.06 8.5h2.04c.143 1.298.535 2.503 1.074 3.5H2.21a6.97 6.97 0 0 1-.942-3.483zM3.63 4.5H2.21A6.97 6.97 0 0 1 3.153 1H4.7a10.87 10.87 0 0 0-.923 3.5zM4.144 8.5H1.06c.07-.639.187-1.265.34-1.856h2.478c-.068.599-.115 1.212-.134 1.856zm3.856 4.58c.458.33.98.594 1.542.793v-1.99a12.18 12.18 0 0 1-1.542-1.383zM8 1c.562.199 1.084.463 1.542.793v1.99a12.18 12.18 0 0 1-1.542 1.383zM11.856 12a12.17 12.17 0 0 1 1.542 1.383v1.99c.562-.199 1.084-.463 1.542-.793zm1.93-3.5h-2.04c-.019-.644-.066-1.257-.134-1.856h2.478c.153.59.27 1.217.34 1.856zM12.37 4.5h1.42a6.97 6.97 0 0 1 .943 3.5h-2.04c-.143-1.298-.535-2.503-1.074-3.5zm-1.144 7h2.28a7.03 7.03 0 0 1-1.074 3.5h-1.37a12.23 12.23 0 0 0 .164-3.5zm-7-7h2.28A7.03 7.03 0 0 1 5.43 1H4.06a12.23 12.23 0 0 0 .164 3.5z"/></svg>`,
                 'ì§€ë„ì íŠ¹ì„±': `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M3.612 15.443c-.386.198-.824-.149-.746-.592l.83-4.73L.173 6.765c-.329-.314-.158-.888.283-.95l4.898-.696L7.538.792c.197-.39.73-.39.927 0l2.184 4.327 4.898.696c.441.062.612.636.282.95l-3.522 3.356.83 4.73c.078.443-.36.79-.746.592L8 13.187l-4.389 2.256z"/></svg>`,
             };
            const iconHtml = icons[title] || '';

            if (containerId === 'time-panel-container' || containerId === 'research-panel-container') {
                 container.innerHTML = `
                    <div class="border border-gray-700 rounded-lg">
                        <div class="bg-gray-700 p-2 flex items-center gap-2 text-yellow-400">
                             ${iconHtml}
                             <h3 class="font-bold text-md">${title}</h3>
                        </div>
                        <div class="p-4 bg-gray-900">${renderer(data)}</div>
                    </div>`;
            } else {
                 container.innerHTML = `
                    <div class="border border-gray-700 rounded-lg">
                        <div class="collapsible-header bg-gray-700 p-2 flex justify-between items-center">
                            <div class="flex items-center gap-2 text-yellow-400">
                                ${iconHtml}
                                <h3 class="font-bold text-md">${title}</h3>
                            </div>
                            <span class="arrow text-yellow-400">â–¼</span>
                        </div>
                        <div class="collapsible-content">
                            <div class="p-4 bg-gray-900">${renderer(data)}</div>
                        </div>
                    </div>`;
            }
        },

        getInternalFactionsHtml(factions) {
             let html = '<div class="grid grid-cols-1 md:grid-cols-3 gap-4">';
             factions.forEach(faction => {
                 let finalLoyalty = faction.loyalty || 50;
                 const loyaltyColor = finalLoyalty > 65 ? 'text-green-400' : finalLoyalty < 35 ? 'text-red-400' : 'text-gray-300';
                 let tooltipHtml = `<strong class='text-yellow-300'>${faction.name} ì¶©ì„±ë„</strong><p class='my-1 text-sm text-gray-400'>${faction.description || 'ì„¸ë ¥ì— ëŒ€í•œ ì„¤ëª…ì´ ì—†ìŠµë‹ˆë‹¤.'}</p><p class='my-1 text-sm text-cyan-400'>ìš”êµ¬: ${faction.desire || 'ì•Œ ìˆ˜ ì—†ìŒ'}</p><hr class='border-gray-600 my-1'><ul class='mt-1 text-sm space-y-1'>`;
                 tooltipHtml += `<li class='font-bold'>í˜„ì¬ ì¶©ì„±ë„: <span class='float-right ${loyaltyColor}'>${Math.floor(finalLoyalty)}</span></li></ul><p class='mt-2 text-xs text-gray-500'>ì˜í–¥ë ¥: ${faction.influence || 0}</p>`;
                 html += `
                     <div class="bg-gray-800 p-3 rounded-md ui-panel-item ui-tooltip text-center">
                         <p class="text-sm text-gray-400 truncate" title="${faction.name}">${faction.name}</p>
                         <p class="text-lg font-bold font-orbitron ${loyaltyColor}">${Math.floor(finalLoyalty)}</p>
                         <div class="tooltip-text">${tooltipHtml}</div>
                     </div>`;
             });
             html += '</div>';
             return html;
        },

        getExternalFactionsHtml(factions) {
            let html = '<div class="grid grid-cols-2 md:grid-cols-4 gap-4">';
            factions.forEach(faction => {
                const relationship = Number(faction.relationship) || 0;
                const relationshipColor = relationship > 25 ? 'text-green-400' : relationship < -25 ? 'text-red-400' : 'text-gray-300';
                
                let tooltipHtml = `<strong class='text-yellow-300'>${faction.name} ê´€ê³„ë„</strong><p class='my-1 text-sm text-gray-400'>ìƒíƒœ: ${faction.status || 'ì•Œ ìˆ˜ ì—†ìŒ'}</p><p class='my-1 text-sm text-cyan-400'>ê´€ê³„ ì´ìœ : ${faction.reason || 'ì•Œ ìˆ˜ ì—†ìŒ'}</p><hr class='border-gray-600 my-1'><ul class='mt-1 text-sm space-y-1'>`;
                tooltipHtml += `<li class='font-bold'>í˜„ì¬ ê´€ê³„ë„: <span class='float-right ${relationshipColor}'>${Math.floor(relationship)}</span></li></ul>`;

                html += `
                    <div class="bg-gray-800 p-3 rounded-md ui-panel-item ui-tooltip text-center">
                        <p class="text-sm text-gray-400 truncate" title="${faction.name}">${faction.name}</p>
                        <p class="text-lg font-bold font-orbitron ${relationshipColor}">${Math.floor(relationship)}</p>
                        <div class="tooltip-text">${tooltipHtml}</div>
                    </div>`;
            });
            html += '</div>';
            return html;
        },

        getLeaderTraitsHtml(traits) {
            let html = '<div class="flex flex-wrap gap-2">';
            traits.forEach(trait => {
                if (!trait || !trait.name) return;
                let tooltipText = `<strong class='text-yellow-300'>${trait.name}</strong><p class='my-1 text-gray-400'>${trait.description}</p>`;
                if (trait.effects && Object.keys(trait.effects).length > 0) {
                    let effectsHtml = '<ul class="mt-2 text-sm space-y-1">';
                    Object.entries(trait.effects).forEach(([stat, value]) => {
                        const baseStat = stat.replace('_bonus', '').replace('_penalty', '');
                        const statLabel = STAT_TRANSLATIONS[baseStat] || baseStat;
                        const color = value >= 0 ? 'text-green-400' : 'text-red-400';
                        const sign = value >= 0 ? '+' : '';
                        effectsHtml += `<li><span class="${color}">${statLabel}:</span> <span class="float-right ${color}">${sign}${value}</span></li>`;
                    });
                    effectsHtml += '</ul>';
                    tooltipText += effectsHtml;
                }
                html += `<div class="ui-tooltip bg-gray-800 px-3 py-1 rounded-md text-sm cursor-help">
                    ${trait.name}<div class="tooltip-text">${tooltipText}</div></div>`;
            });
            html += '</div>';
            return html;
        },

        getNationalSpiritsHtml(spiritIds) {
            let html = '<div class="flex flex-wrap gap-2">';
            spiritIds.forEach(spiritId => {
                const spirit = NATIONAL_SPIRITS[spiritId];
                if (!spirit) return;
                let tooltipText = `<strong class='text-yellow-300'>${spirit.name}</strong><p class='my-1 text-gray-400'>${spirit.description}</p>`;
                tooltipText += (spirit.effects.positive || []).map(e => `<span class='text-green-500'>+ ${e}</span>`).join('<br>');
                tooltipText += '<br>' + (spirit.effects.negative || []).map(e => `<span class='text-red-500'>- ${e}</span>`).join('<br>');
                html += `<div class="ui-tooltip bg-gray-800 px-3 py-1 rounded-md text-sm cursor-help">
                    ${spirit.name}<div class="tooltip-text">${tooltipText}</div></div>`;
            });
            html += '</div>';
            return html;
        },

        createPanelItem(label, value, valueColor, tooltipHtml) {
            if (tooltipHtml) {
                return `
                    <div class="bg-gray-900 p-3 rounded-md ui-panel-item ui-tooltip">
                        <p class="text-sm text-gray-400">${label}</p>
                        <p class="text-lg font-bold font-orbitron ${valueColor}">${value}</p>
                        <div class="tooltip-text">${tooltipHtml}</div>
                    </div>`;
            } else {
                return `<div class="bg-gray-900 p-3 rounded-md ui-panel-item"><p class="text-sm text-gray-400">${label}</p><p class="text-lg font-bold font-orbitron ${valueColor}">${value}</p></div>`;
            }
        },
        renderChoices() {
            const promptEl = document.getElementById('choices-prompt');
            const listEl = document.getElementById('choices-list');
            const event = Events[game.state.world.currentEvent];
            promptEl.textContent = event?.prompt || "ê²°ì •ì„ ë‚´ë¦¬ì‹­ì‹œì˜¤.";
            listEl.innerHTML = '';
            if(!event || !event.choices) return;
            
            let allChoices = [...event.choices];

            // Add fatigue-based choice modification
            if (useFatigueSystem && game.state.playerNation.fatigue > 75) {
                // Disable complex choices
                allChoices = allChoices.map(c => {
                    const cText = c.text.toLowerCase();
                    if (cText.includes('ì™¸êµ') || cText.includes('ì „ëµ') || cText.includes('ì—°êµ¬') || cText.includes('ê³„íš')) {
                        return { ...c, disabled: true, description: "ë„ˆë¬´ í”¼ë¡œí•˜ì—¬ ì´ ì„ íƒì„ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤." };
                    }
                    return c;
                });
                
                const restButton = document.createElement('button');
                restButton.className = "w-full text-left p-4 rounded-lg choice-button bg-blue-700 border-blue-500";
                restButton.innerHTML = `<p class="font-bold text-lg">[íœ´ì‹] ë„ˆë¬´ í”¼ë¡œí•˜ë‹¤. íœ´ì‹ì„ ì·¨í•œë‹¤.</p><p class="text-sm text-gray-400">ë‹¤ìŒ ë‚  ì•„ì¹¨ê¹Œì§€ íœ´ì‹í•˜ì—¬ í”¼ë¡œë¥¼ íšŒë³µí•©ë‹ˆë‹¤.</p>`;
                restButton.onclick = () => {
                    const now = new Date(game.state.world.date);
                    const tomorrow = new Date(now);
                    tomorrow.setDate(tomorrow.getDate() + 1);
                    tomorrow.setHours(9, 0, 0, 0);
                    const restDuration = (tomorrow - now) / 1000;
                    
                    advanceTimeAndAnimate({ seconds: restDuration, isResting: true }, () => {
                        game.Renderer.renderAll();
                    });
                };
                listEl.appendChild(restButton);
            }

            allChoices.forEach(choice => {
                if (!choice) return;
                const button = document.createElement('button');
                button.className = "w-full text-left p-4 rounded-lg choice-button";
                let buttonText = choice.text;
                if (choice.advisorName) {
                    buttonText = `<span class="text-yellow-400">[${choice.advisorName}ì˜ ì œì•ˆ]</span> ${choice.text}`;
                }
                button.innerHTML = `<p class="font-bold text-lg">${buttonText}</p><p class="text-sm text-gray-400">${choice.description}</p>`;
                button.onclick = () => game.update(choice);
                
                button.disabled = choice.disabled;
                if (choice.disabled) {
                    button.classList.add('opacity-50', 'cursor-not-allowed');
                }

                listEl.appendChild(button);
            });
        }
    }
};

// --- DYNAMIC/STATIC GAME DATA ---
const INTELLIGENCE_ACTIONS = {
    request_report: {
        id: 'request_report',
        name: 'íŠ¹ì • ëŒ€ìƒ ë³´ê³  ìš”ì²­',
        description: 'íŠ¹ì • ì¸ë¬¼, ì¡°ì§, ë˜ëŠ” ì‚¬ê±´ì— ëŒ€í•œ ìƒì„¸í•œ ì²©ë³´ ë³´ê³ ì„œë¥¼ ë°›ìŠµë‹ˆë‹¤.',
        cost: 25,
        requiresInput: true,
        inputTitle: 'ì²©ë³´ í™œë™ ì§€ì‹œ',
        inputPrompt: 'ì²©ë³´ í™œë™ ëŒ€ìƒì„ ì…ë ¥í•˜ì‹­ì‹œì˜¤ (ì˜ˆ: ì¹´ë¥´íƒ€ê³  í•´êµ°, í•œë‹ˆë°œ ë°”ë¥´ì¹´):',
        execute: async (state, target) => {
            if (!target || !target.trim()) return;
            const factionInfo = (state.factions || []).map(f => `${f.name}(${f.status})`).join(', ');
            const response = await GEMINI.callGeminiApi("You are a master spy. Provide a concise, insightful intelligence report on the requested target.", `To the Sovereign: Urgent intelligence report regarding "${target}", based on the current world state: Year ${new Date(state.world.date).getFullYear()}, Factions: ${factionInfo}.`);
            if (!response) {
                openReportModal(`ì²©ë³´ ë³´ê³  ì‹¤íŒ¨`, `"${target}"ì— ëŒ€í•œ ì •ë³´ë¥¼ ì–»ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.`);
                return;
            }
            openReportModal(`ì²©ë³´ ë³´ê³ : ${target}`, response.replace(/\n/g, '<br>'));
        }
    },
};

let Scenarios = {};
let Events = {};
let Choices = {};

// --- UI & GAME FLOW FUNCTIONS ---
function showInfoModal(title, message) { openReportModal(title, message); }
function openApiSettingsModal() {
    document.getElementById('modal-api-key-input').value = localStorage.getItem('geminiApiKey') || '';
    document.getElementById('image-api-toggle').checked = localStorage.getItem('useCustomImageApi') === 'true';
    document.getElementById('fatigue-system-toggle').checked = useFatigueSystem;
    document.getElementById('api-settings-modal').classList.remove('hidden');
}
function closeApiSettingsModal() { document.getElementById('api-settings-modal').classList.add('hidden'); }
function saveApiSettings() {
    const apiKey = document.getElementById('modal-api-key-input').value.trim();
    userApiKey = apiKey;
    localStorage.setItem('geminiApiKey', userApiKey);
    useCustomImageApi = document.getElementById('image-api-toggle').checked;
    localStorage.setItem('useCustomImageApi', useCustomImageApi.toString());
    useFatigueSystem = document.getElementById('fatigue-system-toggle').checked;
    localStorage.setItem('useFatigueSystem', useFatigueSystem.toString());

    showInfoModal('ì„¤ì • ì €ì¥', 'ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤. ì¼ë¶€ ì„¤ì •ì€ ê²Œì„ì„ ë‹¤ì‹œ ì‹œì‘í•´ì•¼ ì ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.');
    closeApiSettingsModal();
    if (game.state && game.state.world) {
        game.Renderer.renderAll(); // Re-render to show/hide fatigue panel
    }
}
let onInputModalSubmit = null;
function openInputModal(title, promptText, callback) {
    document.getElementById('input-modal-title').textContent = title;
    document.getElementById('input-modal-prompt').textContent = promptText;
    document.getElementById('input-modal-textarea').value = '';
    document.getElementById('input-modal-textarea').placeholder = promptText;
    onInputModalSubmit = callback;
    document.getElementById('input-modal').classList.remove('hidden');
    document.getElementById('input-modal-textarea').focus();
}
function closeInputModal() { document.getElementById('input-modal').classList.add('hidden'); onInputModalSubmit = null; }
function submitInputModal() {
    const value = document.getElementById('input-modal-textarea').value;
    if (onInputModalSubmit) { onInputModalSubmit(value); }
    closeInputModal();
}

let pendingChoice = null;

function openActionConfirmModal(choice) {
    pendingChoice = choice;
    document.getElementById('action-confirm-modal').classList.remove('hidden');
}

function closeActionConfirmModal() {
    pendingChoice = null;
    document.getElementById('action-confirm-modal').classList.add('hidden');
}

async function getResearchRecommendation() {
    document.getElementById('gemini-loading-overlay').classList.remove('hidden');
    const systemPrompt = `You are a science advisor. Based on the current state, suggest ONE new research project. Respond with ONLY a valid JSON object: {"id": "...", "name": "...", "description": "...", "totalTime": 100, "cost": 50, "effects": [{"type": "RESOURCE", "resource": "techLevel", "change": 1}]}.
    - totalTime is in hours (e.g., 100).
    - cost is for the treasury (e.g., 50).
    - effects are applied on completion.`;
    
    const userPrompt = `Current State: Tech Level ${game.state.playerNation.techLevel}, Treasury: ${game.state.playerNation.treasury}. Suggest one new research project as JSON.`;

    try {
        const responseText = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
        if (!responseText) throw new Error("AI did not suggest research.");

        // FIX: Clean the response text before parsing
        let cleanedText = responseText.trim();
        if (cleanedText.startsWith("```json")) {
            cleanedText = cleanedText.substring(7); // Remove "```json"
        }
        if (cleanedText.startsWith("```")) {
            cleanedText = cleanedText.substring(3); // Remove "```"
        }
        if (cleanedText.endsWith("```")) {
            cleanedText = cleanedText.substring(0, cleanedText.length - 3); // Remove "```"
        }
        cleanedText = cleanedText.trim(); // Trim any whitespace

        const project = JSON.parse(cleanedText);
        
        // Create a new choice based on the project
        const choiceId = `research_prop_${project.id}_${Date.now()}`;
        const newChoice = {
            id: choiceId,
            text: `[ì—°êµ¬ ì œì•ˆ] ${project.name} (ë¹„ìš©: ${project.cost})`,
            description: `${project.description} (ì˜ˆìƒ ì‹œê°„: ${project.totalTime}ì‹œê°„)`,
            execute: (state, choice) => {
                // 1. Check cost
                if (state.playerNation.treasury < project.cost) {
                    openReportModal("ìê¸ˆ ë¶€ì¡±", "ì—°êµ¬ë¥¼ ì‹œì‘í•˜ê¸°ì— êµ­ê³ ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                    return; // Stop execution
                }
                // 2. Apply cost and start research
                game.applyEffects([
                    {"type": "RESOURCE", "resource": "treasury", "change": -project.cost},
                    {"type": "START_RESEARCH", "project": project}
                ]);
                // 3. Proceed to the next event (as if a standard choice was made)
                game.handleStandardChoice(state, choice);
            }
        };
        
        if (!Choices[choiceId]) {
            Choices[choiceId] = newChoice;
        }

        const currentEvent = Events[game.state.world.currentEvent];
        if (!currentEvent.choices.some(c => c.text.includes(project.name))) {
            currentEvent.choices.push(newChoice);
        }
        
        game.Renderer.renderChoices();
        showInfoModal("ì—°êµ¬ ì œì•ˆ", `[${project.name}] ì—°êµ¬ê°€ ì„ íƒì§€ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);

    } catch (e) {
        console.error("Failed to get research recommendation:", e);
        showInfoModal("ì œì•ˆ ì‹¤íŒ¨", "AIê°€ ì—°êµ¬ë¥¼ ì œì•ˆí•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    } finally {
        document.getElementById('gemini-loading-overlay').classList.add('hidden');
    }
}

async function handleAbsurdAction() {
    game.state.absurdityCounter++;
    const counter = game.state.absurdityCounter;
    let title, content;
    if (counter === 1) {
        title = "ì–´ë¦¬ë‘¥ì ˆí•œ ì‹ í•˜ë“¤";
        content = "ë‹¹ì‹ ì˜ ì—‰ëš±í•œ ëª…ë ¹ì— ì‹ í•˜ë“¤ì´ ì ì‹œ ì„œë¡œë¥¼ ì³ë‹¤ë³´ë©° ì–´ë¦¬ë‘¥ì ˆí–ˆì§€ë§Œ, ì´ë‚´ ëª» ë“¤ì€ ì²™í•˜ë©° ë„˜ê¹ë‹ˆë‹¤.";
    } else if (counter === 2) {
        title = "ìˆ˜êµ°ê±°ë¦¬ëŠ” ê¶ì •";
        content = "ë˜ë‹¤ì‹œ ì´ìƒí•œ ë§ì”€ì„ í•˜ì‹œëŠ”êµ°ìš”. ëª‡ëª‡ ì¡°ì–¸ìë“¤ì´ ë‹¹ì‹ ì´ ì—†ëŠ” ê³³ì—ì„œ ë‹¹ì‹ ì˜ ì •ì‹  ê±´ê°•ì— ëŒ€í•œ ìš°ë ¤ë¥¼ í‘œí•˜ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.";
    } else {
        const isAncient = (new Date(game.state.world.date).getFullYear() < 1600);
        title = "ì§€ë„ìì— ëŒ€í•œ ì˜ì‹¬";
        content = isAncient ? "ë‹¹ì‹ ì˜ ê¸°í–‰ì´ ê¶ê¶ ë°–ìœ¼ë¡œ ìƒˆì–´ë‚˜ê°€ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤. ë°±ì„±ë“¤ì€ ë‹¹ì‹ ì´ ê·€ì‹ ì— ì”Œì—ˆê±°ë‚˜, ì •ì‹ ì´ ë‚˜ê°”ë‹¤ê³  ìˆ˜êµ°ê±°ë¦½ë‹ˆë‹¤." : "ë‹¹ì‹ ì˜ ì´í•´í•  ìˆ˜ ì—†ëŠ” ë°œì–¸ë“¤ì´ ì–¸ë¡ ì— ì˜¤ë¥´ë‚´ë¦½ë‹ˆë‹¤. êµ­ë¯¼ë“¤ì€ ì§€ë„ìì˜ ì •ì‹  ìƒíƒœì— ëŒ€í•´ ì‹¬ê°í•œ ì˜ë¬¸ì„ ì œê¸°í•˜ê³  ìˆìŠµë‹ˆë‹¤.";
        const penalty = -(counter - 2) * 2;
        content += `<br><br><span class='text-red-400'>ì†Œë¬¸ìœ¼ë¡œ ì¸í•´ êµ­ê°€ ì•ˆì •ë„ì™€ ì§€ì§€ë„ê°€ ${penalty}% ê°ì†Œí•©ë‹ˆë‹¤.</span>`;
        ['stability', 'approval'].forEach(stat => {
            let modifiers = game.state.playerNation.modifiers[stat];
            if (!modifiers) { game.state.playerNation.modifiers[stat] = []; modifiers = game.state.playerNation.modifiers[stat]; }
            let existingMod = modifiers.find(m => m.name === "êµ°ì£¼ì˜ ê¸°í–‰");
            if (existingMod) { existingMod.value = penalty * (counter-1); } else { modifiers.push({ name: "êµ°ì£¼ì˜ ê¸°í–‰", value: penalty }); }
        });
    }
    openReportModal(title, content);
    game.Renderer.renderUIPanel();
    document.getElementById('custom-action-input').value = "";
}
async function handleCustomAction() {
    const userInput = document.getElementById('custom-action-input').value.trim();
    if (!userInput) { showInfoModal("ì…ë ¥ ì˜¤ë¥˜", "ì§€ì‹œí•  ë‚´ìš©ì„ ì…ë ¥í•˜ì‹­ì‹œì˜¤."); return; }
    if (await isActionAbsurd(userInput, game.state)) { await handleAbsurdAction(); return; }

    const timeToAdvance = estimateTimeForAction(userInput);
    advanceTimeAndAnimate(timeToAdvance, async () => {
        const currentState = game.state;
        await game.updateTendencies(userInput);
        const systemPrompt = "You are a master storyteller for 'The Sovereign's Chronicle'. The player has issued a direct, custom command instead of choosing a pre-defined option. Generate the next event IN KOREAN based on this command. Follow these rules strictly:\n" + "1.  **Interpret the Command:** Analyze the player's command and create a logical, realistic outcome. If the command is impossible or unwise, the narrative should reflect the consequences or difficulties.\n" + "2.  **Acknowledge Context:** Your narrative should reflect the current political situation defined by the key factions.\n" + "3.  **Response Format:** Respond with ONLY the following sections, separated by '---':\n" + "    NARRATIVE: [A compelling story describing the outcome of the player's command.]\n" + "    ---\n" + "    PROMPT: [A new question for the player arising from the new situation.]\n" + "    ---\n" + "    CHOICE 1: [Text for the first new choice.]\n" + "    ---\n" + "    CHOICE 2: [Text for the second new choice.]\n" + "    ---\n" + "    CHOICE 3: [Text for a third new choice (optional).]\n" + "    ---\n" + "    EFFECTS: [A valid JSON array of game state changes.]";
        const factionInfo = (currentState.factions || []).map(f => `${f.name}(${f.status})`).join(', ');
        const userPrompt = `CURRENT SITUATION: The year is ${new Date(currentState.world.date).getFullYear()} for ${currentState.playerNation.name}. The current event is: "${Events[currentState.world.currentEvent].narrative}"\n` + `KEY FACTIONS IN THE REGION: ${factionInfo}\n` + `PLAYER'S DIRECT COMMAND: "${userInput}"\n` + 'Generate the next event that results from this command.';
        const responseText = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
        if (!responseText) { showInfoModal("ëª…ë ¹ í•´ì„ ì‹¤íŒ¨", "AIê°€ ë‹¹ì‹ ì˜ ì§€ì‹œë¥¼ í•´ì„í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); return; }
        const newEvent = game.parseNarrativeResponse(responseText);
        if (!newEvent) { showInfoModal("ì§„í–‰ ë¶ˆê°€", "AIì˜ ì‘ë‹µ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•Šì•„ ì´ì•¼ê¸°ë¥¼ ê³„ì†í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."); return; }
        Events[newEvent.id] = newEvent;
        currentState.world.currentEvent = newEvent.id;
        document.getElementById('custom-action-input').value = "";
        game.checkNationalSpiritFormation();
        await game.Renderer.renderAll();
    });
}
async function playDialogueAudio(element) {
    const textToRead = element.parentElement.querySelector('.dialogue-text').innerText;
    const audioUrl = await GEMINI.callTtsApi(textToRead);
    if (audioUrl) {
        const audioPlayer = document.getElementById('tts-audio-player');
        audioPlayer.src = audioUrl;
        audioPlayer.play();
        audioPlayer.onended = () => URL.revokeObjectURL(audioUrl);
    }
}
async function playNarrativeAudio(buttonEl) {
    const narrativeEl = document.getElementById('narrative-text');
    if (!narrativeEl || buttonEl.disabled) return;
    const originalContent = buttonEl.innerHTML;
    buttonEl.innerHTML = `<svg class="animate-spin h-6 w-6" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>`;
    buttonEl.disabled = true;
    const textToRead = narrativeEl.innerText;
    const audioUrl = await GEMINI.callTtsApi(textToRead);
    if (audioUrl) {
        const audioPlayer = document.getElementById('tts-audio-player');
        audioPlayer.src = audioUrl;
        audioPlayer.play();
        audioPlayer.onended = () => { URL.revokeObjectURL(audioUrl); buttonEl.innerHTML = originalContent; buttonEl.disabled = false; };
        audioPlayer.onerror = () => { showInfoModal("ì˜¤ë””ì˜¤ ì¬ìƒ ì˜¤ë¥˜", "ì˜¤ë””ì˜¤ ì¬ìƒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."); buttonEl.innerHTML = originalContent; buttonEl.disabled = false; }
    } else {
        buttonEl.innerHTML = originalContent;
        buttonEl.disabled = false;
    }
}
function startGame(scenarioId) {
    if(!scenarioId) { showInfoModal("ì˜¤ë¥˜", "ì‹œë‚˜ë¦¬ì˜¤ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤."); return; }
    document.getElementById('start-screen').classList.add('hidden');
    document.getElementById('game-content').classList.remove('hidden');
    document.getElementById('pre-game-header-buttons').classList.add('hidden');
    document.getElementById('in-game-header-buttons').classList.remove('hidden');
    game.init(scenarioId);
}
function updateBriefing(scenarioId, briefing) {
    document.getElementById('briefing-content').innerHTML = `<div id="briefing-metadata"><p><strong class="font-bold">TO:</strong> ${briefing.to}</p><p><strong class="font-bold">FROM:</strong> ${briefing.from}</p><p><strong class="font-bold">DATE:</strong> ${briefing.date}</p></div><hr id="briefing-hr" class="my-4 border-gray-300 block"><p id="briefing-body" class="text-justify leading-relaxed">${(briefing.content || "").replace(/\n/g, '<br>')}</p>`;
    document.getElementById('briefing-title').textContent = (briefing.title || "CLASSIFIED").toUpperCase();
    const startButton = document.getElementById('start-button');
    startButton.dataset.scenarioId = scenarioId;
    startButton.disabled = false;
    startButton.classList.remove('opacity-50', 'cursor-not-allowed');
    startButton.classList.add('hover:bg-blue-900', 'hover:border-blue-900');
}

function showBriefingLoading(message) {
    document.getElementById('briefing-metadata').innerHTML = '';
    document.getElementById('briefing-hr').classList.add('hidden');
    document.getElementById('briefing-body').innerHTML = `
        <div class="flex flex-col items-center justify-center py-8">
            <div class="spinner"></div>
            <p class="mt-4 text-gray-600">${message}</p>
        </div>`;
    const startButton = document.getElementById('start-button');
    startButton.disabled = true;
    startButton.classList.add('opacity-50', 'cursor-not-allowed');
}


async function generateRandomScenario() {
    const randomPrompts = [ "1066ë…„ ë…¸ë¥´ë§Œ ì •ë³µ ì§ì „ì˜ ì‰ê¸€ëœë“œ", "ê¸°ì›ì „ 44ë…„, ì¹´ì´ì‚¬ë¥´ ì•”ì‚´ ì§í›„ì˜ ë¡œë§ˆ", "1868ë…„ ì¼ë³¸ ë©”ì´ì§€ ìœ ì‹ ", "1453ë…„ ì½˜ìŠ¤íƒ„í‹°ë…¸í”Œ ê³µë°©ì „", "1917ë…„ ëŸ¬ì‹œì•„ 10ì›” í˜ëª… ì§ì „", "BC 221ë…„ ì§„ì‹œí™©ì˜ ì¤‘êµ­ í†µì¼", "1776ë…„ ë¯¸êµ­ ë…ë¦½ ì „ìŸ" ];
    const randomPrompt = randomPrompts[Math.floor(Math.random() * randomPrompts.length)];
    await generateCustomScenario(randomPrompt);
}
async function generateCustomScenario(promptOverride = null) {
    const userInput = promptOverride || document.getElementById('era-input').value;
    if (!userInput.trim()) { showInfoModal("ì…ë ¥ ì˜¤ë¥˜", "ì‹œëŒ€ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."); return; }
    if(!promptOverride) { hideEraModal(); }
    
    showBriefingLoading("AIê°€ ìƒˆë¡œìš´ ì—­ì‚¬ì˜ ì¥ì„ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤...");

    const systemPrompt = `You are a historical game designer. Create a detailed starting scenario in KOREAN based on the user's request.
**RULES:**
1.  **Language:** Respond entirely in KOREAN.
2.  **Historical Plausibility:** Provide realistic starting values for all game parameters. **Crucially, the 'techLevel' MUST be appropriate for the requested era.** (e.g., year 1868 should be around level 4-5, not 1).
3.  **JSON Format:** ALL JSON data MUST be valid.
4.  **Provide Modifiers:** You MUST include at least one or two starting modifiers in the 'MODIFIERS' JSON array to reflect unique historical circumstances.
5.  **Strict Response Format:** Use '---' as a separator. The 'FACTIONS' JSON must have 'relationship' and 'reason'. 'INTERNAL_FACTIONS' must have 'desire'.
6.  **Valid Trait Effects:** For the 'effects' object within 'LEADER_TRAITS', you MUST ONLY use keys from this list: [stability, approval, politicalPower, treasury, manpower, resources, techLevel, powerInfluence]. You can add '_bonus' or '_penalty' to them if appropriate, but do not invent new keys.

**RESPONSE FORMAT:**
SCENARIO_NAME: [Plausible Nation Name]
---
DATE: [Historical Start Date]
---
REPORT: [Situation report]
---
STATS: {"stability": 75, "politicalPower": 100, "powerInfluence": 75, "treasury": 1000, "income": {"treasury": 10, "manpower": 5, "resources": 1}, ... "techLevel": 4}
---
MODIFIERS: [{"stat": "stability", "name": "...", "value": -15}]
---
FACTIONS: [{"id": "uk", "name": "ì˜êµ­", "relationship": -10, "status": "ê²½ê³„", "reason": "ìµœê·¼ êµ­ê²½ ë¶„ìŸ"}]
---
INTERNAL_FACTIONS: [{"id": "nobility", "name": "ê·€ì¡±", "loyalty": 40, "influence": 60, "description": "...", "desire": "ë´‰ê±´ ì§ˆì„œ ìœ ì§€"}]
---
LEADER_TRAITS: [{"id": "charismatic", "name": "ì¹´ë¦¬ìŠ¤ë§ˆ", "description": "...", "effects": {"approval_bonus": 10}}]
---
ADVISOR_MILITARY: [Name, Title, Personality, Description]
---
ADVISOR_SCIENCE: [Name, Title, Personality, Description]
---
ADVISOR_TRADE: [Name, Title, Personality, Description]
---
ADVISOR_DIPLOMACY: [Name, Title, Personality, Description]
---
ADVISOR_SATISFACTION: [Name, Title, Personality, Description]`;
    const userPrompt = `Generate a scenario for this theme: "${userInput}"`;
    try {
        const responseText = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
        if (!responseText) throw new Error("AI response was empty.");
        const scenarioData = {};
        responseText.split('---').forEach(section => {
            const [key, ...valueParts] = section.trim().split(':');
            const value = valueParts.join(':').trim();
            if (key && value) { scenarioData[key.trim()] = value; }
        });
        const playerNationName = scenarioData.SCENARIO_NAME || userInput;
        const briefingDate = scenarioData.DATE || 'ì•Œ ìˆ˜ ì—†ìŒ';
        const briefingContent = scenarioData.REPORT;
        if (!briefingContent) throw new Error("AI response did not contain a 'REPORT:' section.");
        
        let stats;
        try { stats = JSON.parse(scenarioData.STATS || '{}'); } catch(e){ stats = {}; console.error("Error parsing STATS JSON", e); }
        
        let modifiersRaw;
        try { modifiersRaw = JSON.parse(scenarioData.MODIFIERS || '[]'); } catch(e){ modifiersRaw = []; console.error("Error parsing MODIFIERS JSON", e); }
        
        let factions;
        try { factions = JSON.parse(scenarioData.FACTIONS || '[]').map(f => ({...f, relationship: Number(f.relationship) || 0 })); } catch(e){ factions = []; console.error("Error parsing FACTIONS JSON", e); }

        let internalFactions;
        try { internalFactions = JSON.parse(scenarioData.INTERNAL_FACTIONS || '[]'); } catch(e){ internalFactions = []; console.error("Error parsing INTERNAL_FACTIONS JSON", e); }
        
        let leaderTraits;
        try { leaderTraits = JSON.parse(scenarioData.LEADER_TRAITS || '[]'); } catch(e){ leaderTraits = []; console.error("Error parsing LEADER_TRAITS JSON", e); }

        const modifiers = {};
        modifiersRaw.forEach(mod => {
            if (!modifiers[mod.stat]) { modifiers[mod.stat] = []; }
            modifiers[mod.stat].push({ name: mod.name, value: mod.value });
        });
        
        const advisors = [];
        const advisorRoles = { 'ADVISOR_MILITARY': 'military', 'ADVISOR_SCIENCE': 'science', 'ADVISOR_TRADE': 'trade', 'ADVISOR_DIPLOMACY': 'diplomacy', 'ADVISOR_SATISFACTION': 'satisfaction' };
        Object.entries(advisorRoles).forEach(([key, role]) => {
            const content = scenarioData[key];
            if (content) {
                const details = content.split(',');
                if (details.length >= 4) { advisors.push({ role, name: details[0].trim(), title: details[1].trim(), personality: details[2].trim(), description: details.slice(3).join(',').trim() }); }
            }
        });
        const scenarioId = 'custom_' + Date.now();
        const isoDate = parseKoreanDateToISO(briefingDate);
        Scenarios[scenarioId] = {
            briefing: { to: "ì§€ë„ì (Player)", from: "ì •ë³´êµ­", date: briefingDate, title: playerNationName, content: briefingContent },
            initialState: {
                playerNation: { 
                    name: playerNationName, 
                    stability: Number(stats.stability) || 75, 
                    politicalPower: Number(stats.politicalPower) || 100, 
                    powerInfluence: Number(stats.powerInfluence) || 75,
                    manpower: Number(stats.manpower) || 500000, 
                    resources: Number(stats.resources) || 100, 
                    treasury: Number(stats.treasury) || 1000, 
                    approval: Number(stats.approval) || 50, 
                    techLevel: Number(stats.techLevel) || 1, 
                    income: stats.income || { treasury: 10, manpower: 5, resources: 1 },
                    modifiers: modifiers 
                },
                world: { date: isoDate, currentEvent: 'custom_event_start' },
                advisors, factions, internalFactions, leaderTraits, policies: [],
                research: { currentProject: null, progress: 0, timeElapsed: 0 }
            },
            initialEvent: { id: 'custom_event_start', narrative: briefingContent, prompt: "ì´ ì¤‘ëŒ€í•œ ìˆœê°„ì—, ì–´ë–¤ ì²«ê±¸ìŒì„ ë‚´ë”›ìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?", choices: [ { id: `custom_1`, text: "ìƒí™©ì„ ì•ˆì •ì‹œí‚¤ê³  ë‚´ë¶€ë¥¼ ë‹¤ì§„ë‹¤.", description: "í˜¼ë€ì„ ìˆ˜ìŠµí•˜ê³  êµ­ë ¥ì„ ë¹„ì¶•í•©ë‹ˆë‹¤." }, { id: `custom_2`, text: "ê³¼ê°í•˜ê²Œ í–‰ë™í•˜ì—¬ ê¸°íšŒë¥¼ ì¡ëŠ”ë‹¤.", description: "ìœ„ê¸°ë¥¼ ê¸°íšŒë¡œ ì‚¼ì•„ ê³µì„¸ì ìœ¼ë¡œ ë‚˜ì„­ë‹ˆë‹¤." }, { id: `custom_3`, text: "ì£¼ë³€ ì„¸ë ¥ê³¼ ì™¸êµì  í•´ë²•ì„ ëª¨ìƒ‰í•œë‹¤.", description: "ì „ìŸë³´ë‹¤ëŠ” ëŒ€í™”ë¥¼ í†µí•´ ë¬¸ì œë¥¼ í•´ê²°í•©ë‹ˆë‹¤." } ] }
        };
        updateBriefing(scenarioId, Scenarios[scenarioId].briefing);
    } catch (e) {
        console.error("Error during custom scenario generation:", e);
        showInfoModal("ìƒì„± ì˜¤ë¥˜", "ì‹œë‚˜ë¦¬ì˜¤ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. AI ì‘ë‹µ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.");
    }
}
function showEraModal() { document.getElementById('era-choice-modal').classList.remove('hidden'); }
function hideEraModal() { document.getElementById('era-choice-modal').classList.add('hidden'); }
function openReportModal(title, content) {
    document.getElementById('report-title').innerHTML = title;
    document.getElementById('report-content').innerHTML = content;
    document.getElementById('report-modal').classList.remove('hidden');
}
function closeReportModal() { document.getElementById('report-modal').classList.add('hidden'); }
function openImageModal(src) { document.getElementById('modal-image').src = src; document.getElementById('image-modal').classList.remove('hidden'); }
function closeImageModal() { document.getElementById('image-modal').classList.add('hidden'); }
async function regenerateCurrentImage() {
    game.isRegenerating = true;
    const imageContainer = document.getElementById('event-image-container');
    imageContainer.innerHTML = `<div class="text-center text-gray-500"><div class="spinner" style="margin: auto;"></div><p class="mt-2 text-sm">âœ¨ ìƒˆë¡œìš´ ì¥ë©´ ìƒì„± ì¤‘...</p></div>`;
    await game.Renderer.generateAndDisplayImage();
}
async function openAdvisorSelector() {
    if (!game.state.advisors || game.state.advisors.length === 0) { showInfoModal("ì˜¤ë¥˜", "í˜„ì¬ ì‹œë‚˜ë¦¬ì˜¤ì— ìë¬¸íšŒê°€ ì—†ìŠµë‹ˆë‹¤."); return; }
    document.getElementById('advisor-selector-modal').classList.remove('hidden');
    const portraitsContainer = document.getElementById('advisor-portraits-container');
    portraitsContainer.innerHTML = '';
    game.selectedAdvisors.clear();
    const roleNames = { military: 'êµ°ì‚¬', science: 'ê³¼í•™', trade: 'ë¬´ì—­', diplomacy: 'ì™¸êµ', satisfaction: 'ë¯¼ì‹¬'};
    game.state.advisors.forEach(advisor => {
        const cell = document.createElement('div');
        cell.className = 'text-center';
        const nameLabel = document.createElement('p');
        nameLabel.className = 'text-sm font-bold mb-1 truncate text-white';
        nameLabel.textContent = advisor.name;
        nameLabel.title = advisor.name;
        const portraitDiv = document.createElement('div');
        portraitDiv.id = `portrait-${advisor.role}`;
        portraitDiv.className = 'advisor-portrait bg-gray-900 rounded flex items-center justify-center mx-auto advisor-portrait-cell';
        if (advisor.imageUrl) {
            portraitDiv.innerHTML = `<img src="${advisor.imageUrl}" class="w-full h-full object-cover rounded">`;
        } else {
            portraitDiv.innerHTML = `<div class="spinner !w-8 !h-8"></div>`;
            (async () => {
                const nationName = game.state.playerNation.name;
                const keywords = HISTORICAL_KEYWORDS[nationName] || HISTORICAL_KEYWORDS['default'];
                const prompt = `Portrait of a ${advisor.description}, from ${nationName}. Style: realistic historical painting. MUST include: ${keywords.positive}. MUST AVOID: ${keywords.negative}.`;
                const imageUrl = await GEMINI.generateImage(prompt);
                advisor.imageUrl = imageUrl;
                portraitDiv.innerHTML = imageUrl ? `<img src="${imageUrl}" class="w-full h-full object-cover rounded">` : 'X';
            })();
        }
        portraitDiv.onclick = () => toggleAdvisorSelection(advisor.role);
        const roleLabel = document.createElement('button');
        roleLabel.className = 'mt-2 px-3 py-1 bg-gray-900 text-white text-sm rounded-md shadow-md';
        roleLabel.textContent = roleNames[advisor.role];
        cell.appendChild(nameLabel);
        cell.appendChild(portraitDiv);
        cell.appendChild(roleLabel);
        portraitsContainer.appendChild(cell);
    });
}
function closeAdvisorSelector() { document.getElementById('advisor-selector-modal').classList.add('hidden'); }
function toggleAdvisorSelection(role) {
    const portrait = document.getElementById(`portrait-${role}`);
    if (game.selectedAdvisors.has(role)) {
        game.selectedAdvisors.delete(role);
        portrait.classList.remove('selected');
    } else {
        game.selectedAdvisors.add(role);
        portrait.classList.add('selected');
    }
}
async function startAdvisorDiscussion() {
    if (game.selectedAdvisors.size === 0) { showInfoModal("ì„ íƒ í•„ìš”", "í† ë¡ ì— ì°¸ì—¬í•  ì¡°ì–¸ìë¥¼ í•œ ëª… ì´ìƒ ì„ íƒí•˜ì‹­ì‹œì˜¤."); return; }
    closeAdvisorSelector();
    await getGroupAdvice();
}
async function getGroupAdvice(isFollowUp = false, userInput = "") {
    const discussionContainer = document.getElementById('advisor-discussion-container');
    const discussionLog = document.getElementById('advisor-discussion-log');
    discussionContainer.classList.remove('hidden');
    let currentHistoryHTML = "";
    if (!isFollowUp) {
        discussionLog.innerHTML = `<div class="p-2 flex justify-center"><div class="spinner !w-5 !h-5"></div></div>`;
        game.newProposals = [];
        game.advisorConversationTextHistory = ""; 
    } else {
        currentHistoryHTML = discussionLog.innerHTML;
        discussionLog.innerHTML += `<div class="p-2 flex justify-center"><div class="spinner !w-5 !h-5"></div></div>`;
    }
    const selectedAdvisors = game.state.advisors.filter(a => game.selectedAdvisors.has(a.role));
    const currentEvent = Events[game.state.world.currentEvent];
    const advisorList = selectedAdvisors.map(a => `- ${a.name} (${a.title}, ${a.personality})`).join('\n');
    const systemPrompt = `You are an AI moderator for a council of historical advisors. Your task is to simulate a dynamic, realistic, and sometimes contentious discussion. **Core Rules:** 1. **Generate Conflict:** If advisors with opposing personalities are present, they MUST argue. 2. **Actionable Proposals:** If an advisor makes a clear suggestion, prefix it with "PROPOSAL:". 3. **Conversational Flow:** Keep responses brief and back-and-forth. 4. **In-Character:** All dialogue must reflect the advisor's personality. 5. **Language:** Respond in Korean. Each line must start with the speaker's name in bold.`;
    
    let userPrompt = `Current Situation: "${currentEvent.narrative}"\n`;

    if (useFatigueSystem && game.state.playerNation.fatigue > 50) {
        const fatigue = game.state.playerNation.fatigue.toFixed(0);
        let fatigueDesc = fatigue > 75 ? "ê·¹ì‹¬í•˜ê²Œ ì§€ì³ íŒë‹¨ë ¥ì´ íë ¤ì§„ ìƒíƒœ" : "ë§¤ìš° í”¼ë¡œí•œ ìƒíƒœ";
        userPrompt += `LEADER'S STATE: í˜„ì¬ ì§€ë„ìëŠ” ${fatigueDesc}ì…ë‹ˆë‹¤ (í”¼ë¡œë„ ${fatigue}%). ëŒ€í™”ì— ì´ ì ì„ ë°˜ì˜í•˜ì‹­ì‹œì˜¤. (ì˜ˆ: ì¡°ì–¸ìë“¤ì´ ê±±ì •, ì§€ë„ìì˜ ë§ì´ ì–´ëˆŒí•´ì§)\n\n`;
    }

    if (game.state.nationalSpirits.length > 0) {
        const spiritNames = game.state.nationalSpirits.map(id => NATIONAL_SPIRITS[id].name).join(', ');
        userPrompt += `Our nation's Spirits: [${spiritNames}]. This should influence opinions.\n\n`;
    }
    userPrompt += `Selected Advisors:\n${advisorList}\n\n`;
    if(isFollowUp && game.advisorConversationTextHistory) {
         userPrompt += `Conversation History:\n${game.advisorConversationTextHistory}\n\n`;
    }
    if(isFollowUp) {
        userPrompt += `My new question is: "${userInput}"\n\nPlease have them discuss this question.`;
    } else {
        userPrompt += `Please have them start a discussion.`;
    }
    const responseText = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
    if (isFollowUp) { discussionLog.innerHTML = currentHistoryHTML; } else { discussionLog.innerHTML = ""; }
    if (responseText) {
        const entries = responseText.split('\n').filter(line => line.trim() !== '');
        let newHtml = "";
        let newTextForHistory = "";
        const speakerIcon = `<span onclick="playDialogueAudio(this)" class="speaker-button" title="ëŒ€ì‚¬ ë“£ê¸°"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg></span>`;
        
        entries.forEach(entry => {
            let speaker = "ì‹œìŠ¤í…œ";
            let dialogue = entry;
            
            const proposalKeyword = 'PROPOSAL:';
            const fullEntryUpper = entry.toUpperCase();
            const proposalIndex = fullEntryUpper.indexOf(proposalKeyword);

            const parts = entry.split(':');
            if (parts.length > 1) {
                speaker = parts[0].trim().replace(/\*/g, '');
                dialogue = parts.slice(1).join(':').trim();
            }

            if (proposalIndex !== -1) {
                let remainingText = entry.substring(proposalIndex + proposalKeyword.length).trim();
                remainingText = remainingText.replace(/^\*+/, '').replace(/\*+$/, '');

                const speakerSplit = remainingText.split(':');
                let speakerForProposal = speaker;
                let proposalTextForChoice = "";

                if (speakerSplit.length > 1 && selectedAdvisors.some(a => a.name === speakerSplit[0].trim().replace(/\*/g, ''))) {
                    speakerForProposal = speakerSplit[0].trim().replace(/\*/g, '');
                    proposalTextForChoice = speakerSplit.slice(1).join(':').trim();
                } else {
                    proposalTextForChoice = remainingText;
                }

                if (proposalTextForChoice) {
                     if (!game.newProposals.some(p => p.text === proposalTextForChoice)) {
                        game.newProposals.push({ advisorName: speakerForProposal, text: proposalTextForChoice });
                    }
                    const styledProposal = `<span class="text-yellow-300 font-bold underline decoration-wavy" title="ì´ ì œì•ˆì´ ì„ íƒì§€ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.">${proposalTextForChoice}</span>`;
                    dialogue = dialogue.replace(new RegExp(proposalTextForChoice.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'i'), styledProposal);
                }
            }
            
            newHtml += `<div class="dialogue-entry"><strong>${speaker}:</strong> <span class="dialogue-text">${dialogue}</span>${speakerIcon}</div>`;
            newTextForHistory += `${speaker}: ${dialogue.replace(/<[^>]*>/g, '')}\n`;
        });

        discussionLog.innerHTML += newHtml;
        game.advisorConversationTextHistory = (game.advisorConversationTextHistory || "") + newTextForHistory;
        discussionLog.scrollTop = discussionLog.scrollHeight;
    } else {
         discussionLog.innerHTML += `<p>ì¡°ì–¸ìë“¤ì´ ì˜ê²¬ì„ ë‚´ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.</p>`;
    }
    updateChoicesWithProposals();
}
async function continueMainScreenDiscussion() {
    const userInput = document.getElementById('advisor-input').value.trim();
    if (!userInput) return;
    if (game.selectedAdvisors.size === 0) { showInfoModal("ì„ íƒ í•„ìš”", "ìë¬¸íšŒ ë²„íŠ¼ì„ í†µí•´ í† ë¡ ì„ ì‹œì‘í•  ì¡°ì–¸ìë“¤ì„ ë¨¼ì € ì„ íƒí•´ì£¼ì‹­ì‹œì˜¤."); return; }
    const discussionLog = document.getElementById('advisor-discussion-log');
    discussionLog.innerHTML += `<div class="dialogue-entry text-yellow-300"><strong>ë‹¹ì‹ :</strong> ${userInput}</div>`;
    game.advisorConversationTextHistory += `ë‹¹ì‹ : ${userInput}\n`;
    document.getElementById('advisor-input').value = "";
    await getGroupAdvice(true, userInput);
}
function updateChoicesWithProposals() {
    const currentEvent = Events[game.state.world.currentEvent];
    if (!currentEvent) return;
    if (!currentEvent.baseChoices) { currentEvent.baseChoices = [...currentEvent.choices]; }
    let newChoices = [...currentEvent.baseChoices];
    if (game.newProposals.length > 0) {
        game.newProposals.forEach(proposal => {
            const choiceId = `advisor_prop_${Date.now()}_${Math.random()}`;
            const newChoice = { id: choiceId, text: proposal.text, description: `${proposal.advisorName} ì¡°ì–¸ìì˜ ì œì•ˆì…ë‹ˆë‹¤.`, advisorName: proposal.advisorName, execute: game.handleStandardChoice.bind(game) };
            if (!newChoices.some(c => c.text === newChoice.text)) {
                 newChoices.push(newChoice);
                 Choices[choiceId] = newChoice;
            }
        });
    }
    currentEvent.choices = newChoices;
    game.Renderer.renderChoices();
}
function openIntelligenceModal() {
    const actionsList = document.getElementById('intelligence-actions-list');
    actionsList.innerHTML = '';
    const currentPower = game.state.playerNation.politicalPower;

    if (Object.keys(INTELLIGENCE_ACTIONS).length === 0) {
        actionsList.innerHTML = `<p class="text-gray-400">í˜„ì¬ ìˆ˜í–‰í•  ìˆ˜ ìˆëŠ” ì²©ë³´ í™œë™ì´ ì—†ìŠµë‹ˆë‹¤.</p>`;
    } else {
        Object.values(INTELLIGENCE_ACTIONS).forEach(action => {
            const canAfford = currentPower >= action.cost;
            const actionDiv = document.createElement('div');
            actionDiv.className = `bg-gray-800 p-4 rounded-lg border-l-4 ${canAfford ? 'border-blue-500' : 'border-red-500'}`;
            
            actionDiv.innerHTML = `
                <div class="flex justify-between items-start">
                    <div>
                        <h4 class="font-bold text-lg">${action.name}</h4>
                        <p class="text-sm text-gray-400 mt-1">${action.description}</p>
                    </div>
                    <div class="text-right ml-4 flex-shrink-0">
                        <p class="font-bold text-lg ${canAfford ? 'text-yellow-400' : 'text-red-500'}">${action.cost} ê¶Œë ¥</p>
                        <button class="mt-2 px-3 py-1 text-sm rounded-md ${canAfford ? 'bg-blue-600 hover:bg-blue-700' : 'bg-gray-600 cursor-not-allowed'}" 
                                onclick="${canAfford ? `performIntelligenceAction('${action.id}')` : ''}" ${!canAfford ? 'disabled' : ''}>
                            ì‹¤í–‰
                        </button>
                    </div>
                </div>`;
            actionsList.appendChild(actionDiv);
        });
    }
    document.getElementById('intelligence-modal').classList.remove('hidden');
}

function closeIntelligenceModal() { 
    document.getElementById('intelligence-modal').classList.add('hidden'); 
}

function performIntelligenceAction(actionId) {
    const action = INTELLIGENCE_ACTIONS[actionId];
    if (!action) return;

    if (game.state.playerNation.politicalPower >= action.cost) {
        game.state.playerNation.politicalPower -= action.cost;
        closeIntelligenceModal();

        if (action.requiresInput) {
            openInputModal(action.inputTitle, action.inputPrompt, (target) => {
                action.execute(game.state, target);
                game.Renderer.renderUIPanel(); // Re-render to show spent power
            });
        } else {
            action.execute(game.state);
            game.Renderer.renderUIPanel(); // Re-render to show spent power
        }
        showInfoModal("ì²©ë³´ í™œë™", `[${action.name}] í™œë™ì„ ìœ„í•´ ê¶Œë ¥ ${action.cost}ì„(ë¥¼) ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.`);
    } else {
        showInfoModal("ê¶Œë ¥ ë¶€ì¡±", "ì²©ë³´ í™œë™ì„ ì‹¤í–‰í•˜ê¸°ì— ê¶Œë ¥ì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
    }
}

async function getResearchRecommendation() {
    document.getElementById('gemini-loading-overlay').classList.remove('hidden');
    const systemPrompt = `You are a science advisor. Based on the current state, suggest ONE new research project. Respond with ONLY a valid JSON object: {"id": "...", "name": "...", "description": "...", "totalTime": 100, "cost": 50, "effects": [{"type": "RESOURCE", "resource": "techLevel", "change": 1}]}.
    - totalTime is in hours (e.g., 100).
    - cost is for the treasury (e.g., 50).
    - effects are applied on completion.`;
    
    const userPrompt = `Current State: Tech Level ${game.state.playerNation.techLevel}, Treasury: ${game.state.playerNation.treasury}. Suggest one new research project as JSON.`;

    try {
        const responseText = await GEMINI.callGeminiApi(systemPrompt, userPrompt);
        if (!responseText) throw new Error("AI did not suggest research.");

        // FIX: Clean the response text before parsing
        let cleanedText = responseText.trim();
        if (cleanedText.startsWith("```json")) {
            cleanedText = cleanedText.substring(7); // Remove "```json"
        }
        if (cleanedText.startsWith("```")) {
            cleanedText = cleanedText.substring(3); // Remove "```"
        }
        if (cleanedText.endsWith("```")) {
            cleanedText = cleanedText.substring(0, cleanedText.length - 3); // Remove "```"
        }
        cleanedText = cleanedText.trim(); // Trim any whitespace

        const project = JSON.parse(cleanedText);
        
        // Create a new choice based on the project
        const choiceId = `research_prop_${project.id}_${Date.now()}`;
        const newChoice = {
            id: choiceId,
            text: `[ì—°êµ¬ ì œì•ˆ] ${project.name} (ë¹„ìš©: ${project.cost})`,
            description: `${project.description} (ì˜ˆìƒ ì‹œê°„: ${project.totalTime}ì‹œê°„)`,
            execute: (state, choice) => {
                // 1. Check cost
                if (state.playerNation.treasury < project.cost) {
                    openReportModal("ìê¸ˆ ë¶€ì¡±", "ì—°êµ¬ë¥¼ ì‹œì‘í•˜ê¸°ì— êµ­ê³ ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.");
                    return; // Stop execution
                }
                // 2. Apply cost and start research
                game.applyEffects([
                    {"type": "RESOURCE", "resource": "treasury", "change": -project.cost},
                    {"type": "START_RESEARCH", "project": project}
                ]);
                // 3. Proceed to the next event (as if a standard choice was made)
                game.handleStandardChoice(state, choice);
            }
        };
        
        if (!Choices[choiceId]) {
            Choices[choiceId] = newChoice;
        }

        const currentEvent = Events[game.state.world.currentEvent];
        if (!currentEvent.choices.some(c => c.text.includes(project.name))) {
            currentEvent.choices.push(newChoice);
        }
        
        game.Renderer.renderChoices();
        showInfoModal("ì—°êµ¬ ì œì•ˆ", `[${project.name}] ì—°êµ¬ê°€ ì„ íƒì§€ì— ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.`);

    } catch (e) {
        console.error("Failed to get research recommendation:", e);
        showInfoModal("ì œì•ˆ ì‹¤íŒ¨", "AIê°€ ì—°êµ¬ë¥¼ ì œì•ˆí•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì‘ë‹µ í˜•ì‹ì´ ì˜ëª»ë˜ì—ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    } finally {
        document.getElementById('gemini-loading-overlay').classList.add('hidden');
    }
}

function toggleCollapsible(header) {
    const content = header.nextElementSibling;
    const arrow = header.querySelector('.arrow');
    if (content.style.maxHeight) {
        content.style.overflow = 'hidden';
        content.style.maxHeight = null;
        arrow.style.transform = 'rotate(0deg)';
    } else {
        content.style.maxHeight = content.scrollHeight + "px";
        arrow.style.transform = 'rotate(180deg)';
        setTimeout(() => { content.style.overflow = 'visible'; }, 300);
    }
}
window.onload = () => {
    document.getElementById('input-modal-cancel').onclick = closeInputModal;
    document.getElementById('input-modal-submit').onclick = submitInputModal;
    document.getElementById('input-modal-textarea').addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); submitInputModal(); }
    });
    
    document.getElementById('action-confirm-cancel').onclick = closeActionConfirmModal;
    document.getElementById('action-confirm-emergency').onclick = () => {
        if (pendingChoice) {
            game.state.world.isEmergency = true;
            const timeToAdvance = estimateTimeForAction(pendingChoice.text);
            advanceTimeAndAnimate(timeToAdvance, async () => {
                await game.processTurn(pendingChoice);
                game.state.world.isEmergency = false; // Reset after action
            });
        }
        closeActionConfirmModal();
    };
    document.getElementById('action-confirm-rest').onclick = () => {
        const now = new Date(game.state.world.date);
        const tomorrow = new Date(now);
        tomorrow.setDate(tomorrow.getDate() + 1);
        tomorrow.setHours(9, 0, 0, 0);
        const restDuration = (tomorrow - now) / 1000; // in seconds
        
        advanceTimeAndAnimate({ seconds: restDuration, isResting: true }, () => {
             if (pendingChoice) {
                const timeToAdvance = estimateTimeForAction(pendingChoice.text);
                 advanceTimeAndAnimate(timeToAdvance, async () => {
                    await game.processTurn(pendingChoice);
                });
             } else {
                game.Renderer.renderAll();
             }
        });
        closeActionConfirmModal();
    };

    document.getElementById('game-content').addEventListener('click', function(e) {
        const header = e.target.closest('.collapsible-header');
        if (header) { toggleCollapsible(header); }
    });
    let activeTooltip = null;
    document.body.addEventListener('mouseover', (e) => {
        const tooltipContainer = e.target.closest('.ui-tooltip');
        if (tooltipContainer) {
            const tooltipText = tooltipContainer.querySelector('.tooltip-text');
            if (tooltipText && tooltipText !== activeTooltip) {
                if(activeTooltip) { activeTooltip.style.visibility = 'hidden'; activeTooltip.style.opacity = '0'; }
                activeTooltip = tooltipText;
                tooltipText.style.visibility = 'visible';
                tooltipText.style.opacity = '1';
                const targetRect = tooltipContainer.getBoundingClientRect();
                const tooltipRect = tooltipText.getBoundingClientRect();
                let top = targetRect.top - tooltipRect.height - 8;
                let left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
                if (top < 0) { top = targetRect.bottom + 8; }
                if (left < 0) left = 8;
                if (left + tooltipRect.width > window.innerWidth) { left = window.innerWidth - tooltipRect.width - 8; }
                tooltipText.style.top = `${top}px`;
                tooltipText.style.left = `${left}px`;
            }
        }
    });
    document.body.addEventListener('mouseout', (e) => {
        const tooltipContainer = e.target.closest('.ui-tooltip');
         if (tooltipContainer) {
             if(activeTooltip) { activeTooltip.style.visibility = 'hidden'; activeTooltip.style.opacity = '0'; activeTooltip = null; }
         }
    });
    document.addEventListener('scroll', () => {
        if (activeTooltip) { activeTooltip.style.visibility = 'hidden'; activeTooltip.style.opacity = '0'; activeTooltip = null; }
    }, true);
    
    const savedApiKey = localStorage.getItem('geminiApiKey');
    if (savedApiKey) { userApiKey = savedApiKey; }
    useCustomImageApi = localStorage.getItem('useCustomImageApi') === 'true';
    useFatigueSystem = localStorage.getItem('useFatigueSystem') === 'true';
};
</script>
</body>
</html>

